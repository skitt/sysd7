%!PS-Adobe-3.0
%%Title: audio.h, board.h, control.h, control_040.h, control_lnx.h, data.h, database.h, gui.h, intserial.h, linux.video.h
%%For: System Design 7
%%Creator: a2ps version 4.9.8
%%CreationDate: Fri May 15 09:23:51 1998
%%BoundingBox: 24 24 571 818
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 51
%%PageOrder: Ascend
%%DocumentMedia: A4 595 842 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%Requirements: duplex 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright (c) 1995, 96, 97 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontMatrix get 3 get 1000 mul
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    FontBBox
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Define these in case they're not in the FontInfo (also, here
    % they're easier to get to.
    /UnderlinePosition 1 def
    /UnderlineThickness 1 def
    
    % Get the underline position and thickness if they're defined.
    currentdict /FontInfo known {
      FontInfo
      
      dup /UnderlinePosition known {
	dup /UnderlinePosition get
	0 exch FontMatrix transform exch pop
	/UnderlinePosition exch def
      } if
      
      dup /UnderlineThickness known {
	/UnderlineThickness get
	0 exch FontMatrix transform exch pop
	/UnderlineThickness exch def
      } if
      
    } if
    currentdict 
  end 
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright (c) 1995, 96, 97 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%IncludeResource: font Courier
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Courier-BoldOblique
%%IncludeResource: font Times-Roman
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /dotlessi /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
%%EndProlog
%%BeginSetup
% Initialize page description variables.
/sh 595 def
/sw 842 def
/llx 24 def
/urx 818 def
/ury 571 def
/lly 24 def
/#copies 1 def
% Pagedevice definitions:
gs_languagelevel 1 gt {
%%BeginFeature: *Duplex True
  << /Duplex true >> setpagedevice
%%EndFeature
} if
/th 15.000000 def
/fnfs 11 def
/bfs 8.005733 def
/cw 4.803440 def

% Dictionary for ISO-8859-1 support
/latin1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   501.959430 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1,1) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( __AUDIO_H__) p n
(#define) K
( __AUDIO_H__) p n
() N
(/*) c n
(  Audio header file for audio compression utilities) N
() N
(  $Id: audio.h,v 1.2 1998/05/07 18:52:02 dwi Exp $) N
(  $Log: audio.h,v $) N
(  Revision 1.2  1998/05/07 18:52:02  dwi) N
(  Just added '#ifndef's.) N
() N
(  Revision 1.1  1998/05/05 15:38:41  iic) N
(  Initial revision) N
() N
(*/) N
() p n
(/* Initialise compression */) c n
() p n
(void) k
( initCompr\(\);) p n
() N
(/* Initialise decompression */) c n
() p n
(void) k
( initDecompr\(\);) p n
() N
() N
(/* Takes two bytes and compresses them into 1 which is returned */) c n
() p n
(unsigned) k
( ) p
(char) k
( compress\() p
(unsigned) k
( ) p
(char) k
(, ) p
(unsigned) k
( ) p
(char) k
(\);) p n
() N
(/* Takes a byte s and a pointer to a two byte buffer to which) c n
(   s will be decompressed */) N
() p n
(void) k
( decompress\() p
(unsigned) k
( ) p
(char) k
(, ) p
(unsigned) k
( ) p
(char) k
( *\);) p n
() N
(#endif) K
( ) p
(/* ndef __AUDIO_H__ */) c n
(audio.h) (Page 1/1) (May 07, 98 19:55) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( __BOARD_H__) p n
(#define) K
( __BOARD_H__) p n
() N
(/* Low-level board functions) c n
(   Stephen Kitt) N
() N
(   Note that not all these functions are actually implemented...) N
(*/) N
() p n
(/* Timer functions */) c n
(void) k
( starttimer \() p
(int) k
(\);) p n
(int) k
( stoptimer \() p
(void) k
(\);) p n
(inline) K
( ) p
(int) k
( gettimer \() p
(void) k
(\);) p n
() N
(/* Checks for the presence of a ring in the Dallas ring reader;) c n
(   returns 1 if there is a ring, 0 otherwise */) N
(int) k
( checkring \() p
(void) k
(\);) p n
() N
(/* Ring information structure */) c n
(typedef) K
( ) p
(struct) k n
({) p n
(  ) S
(unsigned) k
( ) p
(char) k
( product;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( id [6];) p n
(  ) S
(unsigned) k
( ) p
(char) k
( crc;) p n
(} ringinfo;) N
() N
(/* Returns the ring information as a pointer to a ringinfo structure) c n
( */) N
(ringinfo getringinfo \() p
(void) k
(\);) p n
() N
(/* Checks for the presence of a digit on the keypad; returns 1 if) c n
(   there is data, 0 otherwise.) N
(   Note that to get a PIN, we need to wait for this to change to 1,) N
(   get the digit, wait for this to change back to 0, and loop. */) N
(int) k
( checkkeypad \() p
(void) k
(\);) p n
() N
(/* Returns the digit currently on the keypad */) c n
(#define) K
( KP_STAR 0x0A) p n
(#define) K
( KP_HASH 0x0B) p n
(#define) K
( KP_DOORBELL 0x0C) p n
(#define) K
( KP_UNDEF 0xFF) p n
(unsigned) k
( ) p
(char) k
( getkeypad \() p
(void) k
(\);) p n
() N
(/* Returns the current sample from the ADC */) c n
(unsigned) k
( ) p
(char) k
( getsample \() p
(void) k
(\);) p n
() N
(/* Sends a new sample to the DAC */) c n
(void) k
( setsample \() p
(unsigned) k
( ) p
(char) k
(\);) p n
() N
(/* RTC clock structure */) c n
(typedef) K
( ) p
(struct) k n
({) p n
(  ) S
(unsigned) k
( ) p
(char) k
( seconds;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( minutes;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( hours;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( day;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( date;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( month;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( year;) p n
(} rtctime;) N
() N
(/* Get the current RTC time */) c n
(board.h) (Page 1/2) (May 14, 98 23:35) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/audio.h, include/board.h) (1/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2,1) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(rtctime getrtctime \() p
(void) k
(\);) p n
() N
(/* Set the current RTC time */) c n
(void) k
( setrtctime \(rtctime\);) p n
() N
(/* Display a character on the LED display; use -1 to blank */) c n
(void) k
( leddisplay \() p
(unsigned) k
( ) p
(char) k
(\);) p n
() N
(/* Get data from the NVRAM - returns a pointer to a list of bytes) c n
(   extracted from the NVRAM, from the first argument to the last) N
(   inclusive; these can range from 0 to 759 */) N
(unsigned) k
( ) p
(char) k
( * getnvram \() p
(int) k
(, ) p
(int) k
(\);) p n
() N
(/* Set data in the NVRAM */) c n
(void) k
( setnvram \() p
(unsigned) k
( ) p
(char) k
( *, ) p
(int) k
(, ) p
(int) k
(\);) p n
() N
(/* Returns the door's status - 1 is close, 0 is open */) c n
(int) k
( getdoorstatus \() p
(void) k
(\);) p n
() N
(/* Opens the door - returns 0 in case of success, -1 otherwise */) c n
(int) k
( opendoor \() p
(void) k
(\);) p n
() N
(/* Refuse entry */) c n
(int) k
( refuseentry \() p
(void) k
(\);) p n
() N
(/* Executes a no-op */) c n
(#define) K
( nop\(\) asm \(") p
(nop) str
("\)) p n
() N
(/* Activates the buzzer or the LEDs */) c n
(enum) k
( { ALLOFF, BUZZER, LEDGREEN, LEDRED };) p n
(int) k
( buzzerled \() p
(int) k
(\);) p n
() N
(#endif) K
( ) p
(/* ndef __BOARD_H__ */) c n
(board.h) (Page 2/2) (May 14, 98 23:35) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
(  control.h defines enums for various messages which are sent by the) N
(  control module) N
(  $Id: control.h,v 1.7 1998/05/09 14:50:23 iic Exp $) N
(  $Log: control.h,v $) N
(  Revision 1.7  1998/05/09 14:50:23  iic) N
(  Added BUZZER_PRESSED) N
() N
(  Revision 1.6  1998/05/07 19:22:02  dwi) N
(  Added MAKE_TRANSITION to enum.) N
() N
(  Revision 1.5  1998/05/07 19:20:35  skk) N
(  Added comments.) N
() N
(  Revision 1.4  1998/05/04 11:14:45  iic) N
(  *** empty log message ***) N
() N
(  Revision 1.3  1998/05/04 09:39:37  skk) N
(  Changed controltag to controltag_t.) N
() N
(*/) N
() p n
(/* Control packets \(CONTROL datatype\) start with a tag byte which) c n
(   takes a value from the following enum; each control handler should) N
(   compare the first byte of a received control packet with the tags) N
(   it's expecting. Any data after that is defined by the control) N
(   handler's author; so the video control handler needn't know about) N
(   the database control handler. Any unrecognised packets should be) N
(   ignored, because we assume out-of-bounds packets will never be sent ) N
(   \(this also eliminates a slew of DoS attacks\).) N
(*/) N
() p n
(typedef) K
( ) p
(enum) k n
({) p n
(  ) S
(/* Reset Motorola board */) c n
(  RESET_MOTOROLA,) p n
(  RESTART_VIDEO,) N
(  MAKE_TRANSITION,) N
(  BUZZER_PRESSED) N
(} controltag_t;) N
(control.h) (Page 1/1) (May 09, 98 15:50) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/board.h, include/control.h) (2/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* System Design Group 7) c n
( * control_rt_040.h -- Runtime control for motorola board) N
( * EXTERNAL INTERFACE SPECIFICATION) N
( * Edward Knowelden \(ejk\)) N
( */) N
() p n
(#ifndef) K
( __CTRL_RT_040) p n
(#define) K
( __CTRL_RT_040) p n
() N
(#include) K
( ") p
(serial.h) str
(") p n
() N
(void) k
( send_keypad_digit\( ) p
(int) k
( digit \);) p n
(/* Called by LOW_LEVEL upon recieving a digit from the keypad. */) c n
() p n
(void) k
( send_DR_value\( ) p
(int) k
( val \); ) p n
(/* Called by LOW_LEVEL upon recieving a value from the Dallas Ring) c n
( * reader. \(an array may be used if UID is too long for int\) */) N
() p n
(void) k
( doorbell\(\);) p n
(/* Called by LOW_LEVEL if the doorbell is pressed. Will initiate) c n
( * audio/video transmission. Subsequent calls have no effect until GUI) N
( * unlocks door or refuses entry. */) N
() p n
(BOOL handle_ctrldata_040\( packet_t packet \);) N
(/* Called by SERIAL_TRANSPORT_040 when it has a packet of data for the) c n
( * control module. The packet_t datatype is defined by the) N
( * SERIAL_TRANSPORT module as indicated by the #include. Used to) N
( * communicate \(for example\) "unlock door" from remote GUI. In) N
( * practice, an int may used instead of packet_t as no large bits of) N
( * data need to be sent; \(program download will be handled by) N
( * CONTROL_SU_040\). BOOL is for error check.  */) N
() p n
(#endif) K n
() p n
() N
(control_040.h) (Page 1/1) (Apr 27, 98 18:11) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* System Design Group 7) c n
( * control_lnx.h -- Control module for Linux box) N
( * EXTERNAL INTERFACE SPECIFICATION) N
( * Edward Knowelden \(ejk\)) N
( */) N
() p n
(#ifndef) K
( __CTRL_LNX_H__) p n
(#define) K
( __CTRL_LNX_H__) p n
() N
(#include) K
( ") p
(serial.h) str
(") p n
() N
(BOOL handle_ctrldata_lnx\( packet_t packet\);) N
(/* Called by SERIAL_TRANSPORT_LNX when it has a packet of data for the) c n
( * control module. The packet_t datatype is defined by the) N
( * SERIAL_TRANSPORT module as indicated by the #include. Return val) N
( * used for error check. Rx communications include: ) N
( * - Start A/V processing \(on doorbell press\) [CONTROL_RT_040]) N
( * - Log this automatic entry [CONTROL_RT_040]) N
( * - Download program/database [CONTROL_SU_040] */) N
() p n
(void) k
( stop_av\(\);) p n
(/* Called by GUI when a "caller session" is ended. ie. caller is let) c n
( * in or refused entry. Stops audio and video processing \(although) N
( * this could be done directly\). */) N
() p n
(#endif) K n
(control_lnx.h) (Page 1/1) (Apr 29, 98 10:49) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/control_040.h, include/control_lnx.h) (3/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( __DATA_H__) p n
(#define) K
( __DATA_H__) p n
() N
(/* Datatype definitions ) c n
(   $Id: data.h,v 1.9 1998/05/08 15:18:58 skk Exp skk $) N
() N
(*/) N
() p n
(typedef) K
( ) p
(enum) k n
({) p n
(  DEFAULT,) N
(  PING,         ) S
(/* Ping, bidirectional */) c n
(  PING_ACK,     ) p
(/* Ping acknowledge, bidirectional */) c n
(  CONTROL,      ) p
(/* Control information */) c n
(  DATABASE,     ) p
(/* Database information */) c n
(  AUDIO,        ) p
(/* A compressed audio packet, bidirectional */) c n
(  VIDEO         ) p
(/* A compressed video packet, board -> PC only */) c n
(} datatype_t;) p n
() N
(#endif) K
( ) p
(/* ndef __DATA_H__ */) c n
(data.h) (Page 1/1) (May 08, 98 16:19) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* database.h ) c n
( * Definitions for database module - multi-platform header ) N
( */) N
() p n
(#include) K
( <serial.h>) p n
(#include) K
( <data.h>) p n
() N
(#define) K
( DB_FILENAME ") p
(/home/sysd7/source/control/users) str
(") p n
(#define) K
( UID_SIZE 12) p n
(#define) K
( PIN_SIZE 4) p n
(#define) K
( NAME_SIZE 30) p n
(#define) K
( MAX_USERS 10) p n
(#define) K
( ENTRY_ATTEMPTS 3) p n
(#define) K
( TRUE 1) p n
(#define) K
( FALSE 0) p n
() N
(/* CONTROL message identifiers */) c n
(#define) K
( REQUEST_DBDL  111  ) p
(/* request database download */) c n
(#define) K
( REQUEST_NEXT  222  ) p
(/* request the next record */) c n
() p n
(/* a Linux database item definition - stored as a linked list */) c n
(struct) k
( db_struct {) p n
(  ) S
(char) k
( uid[UID_SIZE+1];) p n
(  ) S
(char) k
( pin[PIN_SIZE+1];) p n
(  ) S
(char) k
( fname[NAME_SIZE+1];) p n
(  ) S
(char) k
( sname[NAME_SIZE+1];) p n
(  ) S
(char) k
( dept[NAME_SIZE+1];) p n
(  ) S
(char) k
( photo[NAME_SIZE];) p n
(  ) S
(char) k
( lock;) p n
(  ) S
(struct) k
( db_struct *next;) p n
(};) N
() N
(typedef) K
( ) p
(struct) k
( db_struct db_item;) p n
() N
(/* a locally stored database item. */) c n
(typedef) K
( ) p
(struct) k
( {) p n
(  ) S
(char) k
( uid[UID_SIZE+1];) p n
(  ) S
(int) k
( pin;) p n
(} local_db_item;) N
(  ) N
(/* motorola function prototypes */) c n
() p n
(int) k
( request_db\(\);) p n
(void) k
( handle_db_data\(packet p\);) p n
(int) k
( send_keypad_digit\() p
(int) k
( digit\);) p n
(int) k
( validate_user\() p
(char) k
( *uid, ) p
(int) k
( pin\);) p n
() N
(/* linux function prototypes */) c n
(int) k
( db_download\(\);) p n
(int) k
( load_database\(\);) p n
(void) k
( handle_control_data\(packet *p\);) p n
(db_item *get_db_item\() S
(char) k
( *name\);) p n
() N
(/* support functions */) c n
(int) k
( itos\() p
(int) k
(,) p
(char) k
( *,) p
(int) k
(\);) p n
(int) k
( strcomp\() p
(char) k
( *string1,) p
(char) k
( *string2\);) p n
(void) k
( strcopy\() p
(char) k
( *to, ) p
(char) k
( *from\);) p n
() N
(/* test functions */) c n
(void) k
( mtr_senddata\(packet p\);) p n
(int) k
( lnx_senddata\(packet p\);) p n
(void) k
( unlock_door\(\);) p n
(database.h) (Page 1/1) (May 14, 98 17:17) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/data.h, include/database.h) (4/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* System Design Group 7) c n
( * gui.h -- Linux GUI) N
( * EXTERNAL INTERFACE SPECIFICATION) N
( * Edward Knowelden \(ejk\)) N
( */) N
() p n
(#ifndef) K
( __GUI_H__) p n
(#define) K
( __GUI_H__) p n
() N
(#include) K
( ") p
(linux.video.h) str
(") p n
() N
(void) k
( gui_display_frame\(frame_t *frame\);) p n
(/* Called by VIDEO_LNX when it has decoded a frame. Copies frame from) c n
( * specified location and displays it in a window. The frame type is) N
( * specified in linux.video.h. */) N
() p n
(void) k
( gui_display_uid\() p
(int) k
( uid\);) p n
(/* Called by CONTROL_LNX if it receives a uid from motorola board and) c n
( * the GUI is active. ie. if someone uses a DR to gain access. */) N
() p n
(#endif) K n
(gui.h) (Page 1/1) (Apr 28, 98 13:54) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( __SERIAL_H__) p n
(#define) K
( __SERIAL_H__) p n
() N
(/* Serial interface definitions) c n
(   $Id: serial.h,v 1.7 1998/04/30 08:28:20 skk Exp skk $) N
(   $Log: serial.h,v $) N
(   Revision 1.7  1998/04/30 08:28:20  skk) N
(   Added init/shutdown functions.) N
() N
(   Revision 1.6  1998/04/29 14:53:57  skk) N
(   Added ping function.) N
() N
( */) N
() p n
(/* External packet structure */) c n
(typedef) K
( ) p
(struct) k n
({) p n
(  ) S
(unsigned) k
( ) p
(char) k
( datatype;) p n
(  ) S
(unsigned) k
( ) p
(int) k
( length;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( * data;) p n
(} packet;) N
() N
(/* Packet handler - this is a pointer to a function which takes a) c n
(   pointer to a packet and returns nothing */) N
(typedef) K
( ) p
(void) k
( \(* packethandler\) \(packet *\);) p n
() N
(/* Initialises the serial stuff */) c n
(int) k
( serialinit \() p
(void) k
(\);) p n
() N
(/* Shuts the serial down */) c n
(int) k
( serialclose \() p
(void) k
(\);) p n
() N
(/* Queues a packet to be sent across the serial line */) c n
(/* Input: pointer to a packet */) N
(/* Output: 0 for success, errno-type code otherwise \(include) N
(   <errno.h>\) */) N
(int) k
( senddata \(packet *\);) p n
() N
(/* Registers a data handler for a given data type */) c n
(/* Input: datatype to be handled \(can be DEFAULT\), pointer to a) N
(   function taking a packet as input */) N
(/* Output: 0 for success */) N
(int) k
( registerhandler \() p
(unsigned) k
( ) p
(char) k
(, packethandler\);) p n
() N
(/* Removes the data handler for the given type; note that a default) c n
(   handler is always available \(it discards everything\) and will be) N
(   reinstated if the default is removed */) N
(/* Input: datatype to be removed */) N
(int) k
( unregisterhandler \() p
(unsigned) k
( ) p
(char) k
(\);) p n
() N
(/* Returns 1 if the opposite communicator is alive, 0 if it isn't */) c n
(int) k
( ping \() p
(void) k
(\);) p n
() N
(/* Grabs a frame from the camera; this ensures we don't suffer from) c n
(   the camera v serial conflict. */) N
(int) k
( grabframe \() p
(unsigned) k
( ) p
(char) k
( *\);) p n
() N
(#endif) K
( ) p
(/* ndef __SERIAL_H__ */) c n
(intserial.h) (Page 1/1) (May 08, 98 13:23) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/gui.h, include/intserial.h) (5/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( _linux_video_h_) p n
(#define) K
( _linux_video_h_) p n
() N
(/*) c n
(  Linux Machine Video Interface) N
(  Ian Clarke \(iic@dcs.ed.ac.uk\)) N
(  $Id: linux.video.h,v 1.4 1998/05/07 14:04:22 iic Exp iic $) N
(  $Log: linux.video.h,v $) N
(  Revision 1.4  1998/05/07 14:04:22  iic) N
(  Added restartVideo) N
() N
(  Revision 1.3  1998/04/29 09:51:06  iic) N
(  *** empty log message ***) N
() N
(  Revision 1.2  1998/04/28 12:58:17  iic) N
(  *** empty log message ***) N
() N
() N
( */) N
() p n
(/* Initialise The video handler */) c n
() p n
(void) k
( initVideo\(\);) p n
() N
(#endif) K n
(linux.video.h) (Page 1/1) (May 09, 98 15:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( _motorola_video_h_) p n
(#define) K
( _motorola_video_h_) p n
() N
(/*) c n
(  Motorola Video Interface) N
(*/) N
() p n
(/* ) c n
() N
(   /* RLE Encoding function:) N
( `src' is a pointer to an array of unsigned chars of length sLen) N
(   where only the 4 least significant bits are to be compressed.) N
(  `dst' is a pointer to a buffer which should be of at least) N
(   size \(sLen*8\)/5+1.) N
(  This buffer will be filled with a RLE encoded version of src) N
(  and the function will return the compressed length in bits.) N
(                                                        ^^^^) N
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T () S 48 T () S 56 T (*/) N
() p n
(int) k
( RLEencode\() p
(unsigned) k
( ) p
(char) k
( *, ) p
(int) k
(, ) p
(unsigned) k
( ) p
(char) k
( *\);) p n
() N
() N
(#endif) K n
(motorola.video.h) (Page 1/1) (May 04, 98 12:06) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/linux.video.h, include/motorola.video.h) (6/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( __SERIAL_H__) p n
(#define) K
( __SERIAL_H__) p n
() N
(/* Serial interface definitions) c n
(   Stephen Kitt) N
() N
(   Note that this requires SDPMotorola to be defined if used in) N
(   Motorola code) N
( */) N
() p n
(/* External packet structure */) c n
(typedef) K
( ) p
(struct) k n
({) p n
(  ) S
(unsigned) k
( ) p
(char) k
( datatype;) p n
(  ) S
(unsigned) k
( ) p
(int) k
( length;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( * data;) p n
(} packet;) N
() N
(/* Packet handler - this is a pointer to a function which takes a) c n
(   pointer to a packet and returns nothing */) N
(typedef) K
( ) p
(void) k
( \(* packethandler\) \(packet *\);) p n
() N
(/* Initialises the serial stuff */) c n
(int) k
( serialinit \() p
(void) k
(\);) p n
() N
(/* Shuts the serial down */) c n
(int) k
( serialclose \() p
(void) k
(\);) p n
() N
(/* Queues a packet to be sent across the serial line */) c n
(/* Input: pointer to a packet */) N
(/* Output: 0 for success, errno-type code otherwise \(include) N
(   <errno.h>\) */) N
(int) k
( senddata \(packet *\);) p n
() N
(/* Registers a data handler for a given data type */) c n
(/* Input: datatype to be handled \(can be DEFAULT\), pointer to a) N
(   function taking a packet as input */) N
(/* Output: 0 for success */) N
(int) k
( registerhandler \() p
(unsigned) k
( ) p
(char) k
(, packethandler\);) p n
() N
(/* Removes the data handler for the given type; note that a default) c n
(   handler is always available \(it discards everything\) and will be) N
(   reinstated if the default is removed */) N
(/* Input: datatype to be removed */) N
(int) k
( unregisterhandler \() p
(unsigned) k
( ) p
(char) k
(\);) p n
() N
(/* Returns 1 if the opposite communicator is alive, 0 if it isn't */) c n
(int) k
( ping \() p
(void) k
(\);) p n
() N
(/* Transmits a single byte of data */) c n
(int) k
( serialtransmit \() p
(unsigned) k
( ) p
(char) k
(\);) p n
() N
(/* Received a single byte of data, or -1 in case of timeout */) c n
(int) k
( serialreceive \() p
(void) k
(\);) p n
() N
(/* Sends a change state message */) c n
(#ifndef) K
( SDPMotorola) p n
(void) k
( changestate \() p
(unsigned) k
( ) p
(char) k
(\);) p n
(#endif) K n
() p n
(/* Receives a packet */) c n
(#ifdef) K
( SDPMotorola) p n
(serial.h) (Page 1/2) (May 14, 98 23:34) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(packet * receivepacket \() p
(void) k
(\);) p n
(#endif) K n
() p n
(/* Enables packets */) c n
(#ifndef) K
( SDPMotorola) p n
(void) k
( enablepackets \() p
(void) k
(\);) p n
(#endif) K n
() p n
(/* Disables packets */) c n
(#ifndef) K
( SDPMotorola) p n
(void) k
( disablepackets \() p
(void) k
(\);) p n
(#endif) K n
() p n
(#endif) K
( ) p
(/* ndef __SERIAL_H__ */) c n
(serial.h) (Page 2/2) (May 14, 98 23:34) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/serial.h) (7/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifndef) K
( __SUPPORT_H__) p n
(#define) K
( __SUPPORT_H__) p n
() N
(/* General support routines, supplied by libsupport) c n
(   Stephen Kitt) N
(*/) N
() p n
(#ifdef) K
( SDPMotorola) p n
(/* Motorola section */) c n
() p n
(/* puts outputs the string given as argument on the console \(either) c n
(   Minicom on channel A \(ttyS0\) or stdout\)) N
(*/) N
(void) k
( puts \() p
(char) k
( *\);) p n
() N
(#else) K n
(/* Linux section */) c n
() p n
(#include) K
( <stdio.h>) p n
() N
(#endif) K
( ) p
(/* SDPMotorola */) c n
() p n
(/* Common section */) c n
() p n
(/* putn outputs the number given as argument in the specified base) c n
(   with the specified number of digits on the console) N
(*/) N
(void) k
( putn \() p
(unsigned) k
( ) p
(long) k
(, ) p
(int) k
(, ) p
(int) k
(\);) p n
() N
(#endif) K
( ) p
(/* __SUPPORT_H__ */) c n
(support.h) (Page 1/1) (May 14, 98 23:34) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* audio.c) c n
(   -- contains the definitions for the audio codec routines.) N
() N
(*/) N
(#include) K
( <audio.h>) p n
() N
(/*) c n
(.---------------------------------------------------------------------------.) N
(|  This is a lookup table of coded deltas.                                  |) N
(|  i.e. nib_lookup[sample_delta] gives you the relevant 4-bit encoding.     |) N
(|---------------------------------------------------------------------------|*/) N
(unsigned) k
( ) p
(char) k
( nib_lookup[]={) p n
(  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,) N
(  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,) N
(  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,) N
(  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,) N
(  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,) N
(  1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,) N
(  2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,) N
(  3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 7,) N
(  7, 8, 9, 9, 10,10,10,11,11,11,11,11,11,12,12,12,) N
(  12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,) N
(  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,) N
(  13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,) N
(  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,) N
(  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,) N
(  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,) N
(  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15};) N
(/*                                                                          |) c n
(`---------------------------------------------------------------------------'*/) N
() p n
() N
() N
(/*) c n
(.---------------------------------------------------------------------------.) N
(|  This is the decoding table.  It performs the inverse mapping.            |) N
(|  ie unnib_lookup[4_bit_code] returns the estimated delta for the sample.  |) N
(|---------------------------------------------------------------------------|*/) N
(char) k
( unnib_lookup[]={-128,-64,-32,-16,-8 ,-4 ,-2 ,-1, 1 , 2 , 4 , 8 ,16 ,32 ,64 ) p n
(,127};) N
(/*                                                                          |) c n
(`---------------------------------------------------------------------------'*/) N
() p n
() N
(/***************************************************************************) c n
( * Previous sample values for encoding and decoding respectively           *) N
( *                                                                         */) N
(unsigned) k
( ) p
(char) k
( prev_val_c, prev_val_d;) p n
(/***************************************************************************/) c n
() p n
() N
(/* ) c n
(   Initialise compression) N
(   set the previous sample value to 128 which is the normal zero value for ) N
(   sampling.) N
(*/) N
(void) k
( initCompr\(\)) p n
({) N
(  prev_val_c=128;) N
(}) N
() N
(/*) c n
(audio.c) (Page 1/3) (May 15, 98 0:00) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(include/support.h, audio.c) (8/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2-3) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  Initialise decompression) c n
(  Same as above.) N
(*/) N
() p n
(void) k
( initDecompr\(\)) p n
({) N
(  prev_val_d=128;) N
(}) N
() N
(/**************************************************) c n
(      --=[  Compression routines.   ]=--) N
(**************************************************/) N
(/*) N
(  compressI\(\) Takes an unsigned 8-bit sample and compresses it,) N
(  returns the 4-bit encoding in the lower 4 bits of the byte.) N
(*/) N
() p n
(unsigned) k
( ) p
(char) k
( compressI\() p
(unsigned) k
( ) p
(char) k
( sample\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(char) k
( ret;) p n
(  ) S
(/* Find the estimated delta encoding */) c n
(  ret=nib_lookup[128+sample-prev_val_c];) p n
(  ) S
(/* modify the prev_val to reflect the decompressed estimation */) c n
(  prev_val_c+=unnib_lookup[ret];) p n
(  ) S
(/* Stop and return the compressed value. */) c n
(  ) p
(return) K
( ret;) p n
(}) N
() N
(/*) c n
(  Takes two unsigned 8-bit samples and compresses them into 1 byte,) N
(  which is returned with the first sample's encoding in the lower) N
(  half of the byte and the second one's in the high half.) N
(*/) N
() p n
(unsigned) k
( ) p
(char) k
( compress\() p
(unsigned) k
( ) p
(char) k
( sample1, ) p
(unsigned) k
( ) p
(char) k
( sample2\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(char) k
( t1,t2;) p n
(  ) S
(/* Compress the first sample and store it temporarily. */) c n
(  t1=compressI\(sample1\);) p n
(  ) S
(/* Compress the second sample, bit shift it 4 places up the byte) c n
(     and append the encoding of the first sample */) N
(  t2=\(compressI\(sample2\)<<4\)|t1;) p n
(  ) S
(/* Stop and return the two encodings packed as one byte. */) c n
(  ) p
(return) K
( t2;) p n
(}) N
() N
() N
(/**************************************************) c n
(      --=[ Decompression routines. ]=--) N
(**************************************************/) N
() p n
(/*) c n
(  Takes a byte, s, containing the right-justified 4-bit encoding of the) N
(  sample delta and returns the estimation of the next sample.) N
(*/) N
() p n
(unsigned) k
( ) p
(char) k
( decompressI\() p
(unsigned) k
( ) p
(char) k
( s\)) p n
({) N
(  ) S
(/* Find the estimated delta for the encoding and modify the previous) c n
(     sample accordingly. */) N
(  prev_val_d+=unnib_lookup[s];) p n
(  ) S
(/* Stop and return the estimation of the next sample. */) c n
(audio.c) (Page 2/3) (May 15, 98 0:00) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(return) K
( prev_val_d;) p n
(}) N
() N
(/*) c n
(  Takes a byte, s, containing two, 4-bit delta encodings,and a pointer) N
(  to a two byte buffer to which s will be decompressed this buffer will) N
(  then contain the next two samples to be played with the first byte in) N
(  the buffer representing the first of the two samples.) N
(*/) N
() p n
(void) k
( decompress\() p
(unsigned) k
( ) p
(char) k
( s, ) p
(unsigned) k
( ) p
(char) k
( *dst\)) p n
({) N
(  ) S
(/* extract the lower half of the byte and use it to produce the estimated) c n
(     sample to be played first. */) N
(  dst[0]=decompressI\(s & 0x0F\);) p n
(  ) S
(/* extract the high half of the byte and shift it into the lower half,) c n
(     then use it to create the second sample of the pair. */) N
(  dst[1]=decompressI\(\(\(s & 0xF0\)>>4\)&0x0F\);) p n
(}) N
(audio.c) (Page 3/3) (May 15, 98 0:00) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(audio.c) (9/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* audio_main.c) c n
(   -- Linux-side audio system.) N
(   ) N
(   Compile with :) N
(   gcc -I/home/sysd7/source/include/ -O2 -o linuxtest lstate4.c ../audio.c ~/sou) N
(rce/transport/linux/interrupt.c) N
(   ) N
(   A shed-load of includes...) N
(*/) N
(#include) K
( <sys/ioctl.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <fcntl.h>) p n
(#include) K
( <sys/soundcard.h>) p n
(#include) K
( <audio.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <serial.h>) p n
(#include) K
( <data.h>) p n
(#include) K
( <control.h>) p n
(#include) K
( <signal.h>) p n
() N
(/*) c n
(  Define the buffer sizes for playing and recording sound.) N
(*/) N
(#define) K
( PLAY_BUF_SIZE 4096) p n
(#define) K
( SAMPLE_BUF_SIZE 4096) p n
(#define) K
( PLAY_FRAG 12) p n
(#define) K
( SAMPLE_FRAG 12) p n
() N
(/*) c n
(  Uncomment this define to make the software automatically alter the mixer) N
(  settings.  This is to be used to stop feed-back loops on the PC since the) N
(  microphone's input is played directly to the speaker.) N
(*/) N
(/*#define MIXER_TWEAKS */) N
() p n
(/* Some global variables for accessing the OSS audio */) c n
(int) k
( audio_fd,len;) p n
(#ifdef) K
( MIXER_ TWEAKS) p n
(int) k
( mixer_fd;) p n
(#endif) K
( ) p n
() N
(/* Variables for indicating state changes */) c n
(/* I don't think that TranstionTo is actually used anymore but it's still) N
(   here just in case. */) N
(unsigned) k
( ) p
(char) k
( TransitionTo=0;) p n
(/*Curstate is set to the current audio state with respect to the IDP state-) c n
(  machine paradigm.  The signal handler sets it to another state if it want) N
(  the audio to switch states.) N
(*/) N
(int) k
( Curstate;) p n
() N
(/* Structure for setting up the signal handler for IPC */) c n
(struct) k
( sigaction signals;) p n
() N
() N
(/**********) c n
() S 8 T (   Buffers for Tx Data ) N
() S 8 T (   Fairly self-explanatory...) N
(*/) N
(unsigned) k
( ) p
(char) k
( audioIn_Buf[SAMPLE_BUF_SIZE];) p n
(unsigned) k
( ) p
(char) k
( serialOut_Buf[SAMPLE_BUF_SIZE/2];) p n
(audio_main.c) (Page 1/10) (May 15, 98 4:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(int) k
( Tx_Data_count=0;) p n
() N
() N
(/***********) c n
() S 8 T (    Buffers for Rx Data ) N
() S 8 T (    Ditto...) N
(*/) N
(unsigned) k
( ) p
(char) k
( audioOut_Buf[PLAY_BUF_SIZE];) p n
(unsigned) k
( ) p
(char) k
( serialIn_Buf[PLAY_BUF_SIZE/2];) p n
(int) k
( Rx_Data_count=0;) p n
() N
() N
() N
(/***************************************) c n
(*  Soundcard initialisation routine.   *) N
(****************************************/) N
() p n
(int) k
( init_audio \() p
(int) k
( Mode\)) p n
({) N
(  ) S
(int) k
( retry = 10;) p n
(  ) S
(int) k
( mono;) p n
(  ) S
(/* Open the soundcard on /dev/dsp */) c n
(  ) p
(while) K
( \(retry-- && \(audio_fd = open \(") p
(/dev/dsp) str
(", Mode, 0\)\) == -1\) {) p n
(    fprintf \(stderr, ") S
(error [\(Duncan\) lstate4.c/init_soundcard] : couldn't open /dev/dsp\\nTrying again...\\n) str
(") p n
(\);) N
(    sleep\(5\);) N
(    ) S
(/*    exit \(EXIT_FAILURE\);*/) c n
(  }) p n
(  ) S
(if) K
( \(audio_fd == -1\)) p n
(    ) S
(return) K
( -1;) p n
(  ) N
(  ) S
(/*) c n
(    Set the buffered fragment size so that there is less delay.) N
(    This was supposed to be configurable from the defines above, but it) N
(    didn't seem to work, so I've hard-coded it.) N
(  */) N
(  ) p
(if) K
( \(Mode==O_RDONLY\)) p n
(    ) S
(/*mono=0x7fff0000&SAMPLE_FRAG;*/) c n
(    mono=0x7FFF000C;) p n
(  ) S
(else) K n
(    mono=0x7FFF000C;) p n
(  ) S
(/*mono=0x7fff0000&PLAY_FRAG;*/) c n
(  ) p
(if) K
( \(ioctl\(audio_fd, SNDCTL_DSP_SETFRAGMENT, &mono\) == -1\){) p n
(    fprintf\(stderr,") S
(error [\(Duncan\) lstate4.c/init_audio\(\) : Couldn't set the fragment size properly, this may r) str n
(esult in glitchy sound.\\n) S
("\);) p n
(    fprintf\(stderr,") S
(ioctl call Returned : %X\\n) str
(",mono\);) p n
(    ) S
(return) K
( 2;) p n
(  }) N
(  ) N
(  ) S
(/*) c n
(    Set to mono operation.) N
(  */) N
(  mono=0;) p n
(  ) S
(if) K
( \(ioctl \(audio_fd, SNDCTL_DSP_STEREO, &mono\) == -1\) {) p n
(    fprintf \(stderr, ") S
(error [\(Duncan\) lstate4.c/init_audio\(\)] : problem setting mono operation?!?!) str
("\);) p n
(    ) S
(return) K
( 3;) p n
(  }) N
(  ) N
(  ) S
(/*) c n
(    set it to 8-bit unsigned sampling.) N
(  */) N
(  mono = AFMT_U8;) p n
(audio_main.c) (Page 2/10) (May 15, 98 4:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/audio_main.c) (10/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3-4) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(if) K
( \(ioctl \(audio_fd, SNDCTL_DSP_SETFMT, &mono\) == -1\) {) p n
(    fprintf\(stderr,") S
(error [\(Duncan\) lstate4.c/init_audio\(\)] : problem setting unsigned 8-bit mode.) str
("\);) p n
(    ) S
(return) K
( 4;) p n
(  }) N
(  ) N
(  ) S
(/*) c n
(    set it to 8kHz sampling rate.) N
(    This assignment is a hangover from testing, I've decided to leave it in) N
(    this comment for the time being.) N
(    mono = 6250;) N
(  */) N
(  mono = 8000;) p n
(  ) S
(if) K
( \(ioctl \(audio_fd, SNDCTL_DSP_SPEED, &mono\) == -1\) {) p n
(    fprintf\(stderr,") S
(error [\(Duncan\) lstate4.c/init_audio\(\)] : problem setting sampling rate.) str
("\);) p n
(    ) S
(return) K
( 5;) p n
(  }) N
(  ) N
(  ) S
(/*) c n
(    Initialise the audio subsystem...) N
(  */) N
(  TransitionTo=0;) p n
(  ) S
(return) K
( 0;) p n
(}) N
() N
() N
(/*) c n
(  It does exactly what it says on the tin!) N
(*/) N
(void) k
( close_audio\() p
(void) k
(\)) p n
({) N
(  close \(audio_fd\);) N
(}) N
() N
(#ifdef) K
( MIXER_TWEAKS) p n
(/****************************************************************************) c n
(   --=[ Mixer Functions ]=--) N
(   only active if MIXER_TWEAKS is #defined.) N
(*****************************************************************************/) N
(/* opens the mixer device */) N
(int) k
( init_mixer\() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( mixer;) p n
(  ) S
(/* Open the audio mixer on /dev/mixer */) c n
(  ) p
(if) K
( \(\(mixer_fd = open \(") p
(/dev/mixer) str
(", O_WRONLY, 0\)\) == -1\) {) p n
(    fprintf \(stderr, ") S
(error [\(Duncan\) lstate4.c/init_mixer] : couldn't open /dev/mixer) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Set the volume of the speakers */) c n
(int) k
( mixer_volume\() p
(int) k
( volume\) ) p n
({) N
(  ) S
(if) K
( \(ioctl \(mixer_fd, SOUND_MIXER_VOLUME, &volume\) == -1\) {) p n
(    fprintf \(stderr, ") S
(error [\(Duncan\) lstate4.c/mixer_volume] : problem setting volume) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Set the recording level of the microphone */) c n
(int) k
( mixer_mic_level\() p
(int) k
( level\)) p n
(audio_main.c) (Page 3/10) (May 15, 98 4:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
({) p n
(  ) S
(if) K
( \(ioctl \(mixer_fd, SOUND_MIXER_MIC, &level\) == -1\) {) p n
(    fprintf \(stderr, ") S
(error [\(Duncan\) lstate4.c/mixer_mic_level] : problem setting level) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
() N
(/* Go on... have a guess. */) c n
(void) k
( close_mixer\() p
(void) k
(\)) p n
({) N
(  close \(mixer_fd\);) N
(}) N
() N
(#endif) K n
() p n
() N
() N
(/***********************************) c n
(  Audio Tx routines...) N
(***********************************/) N
() p n
(/* Samples the microphone into the buffer pointer at by buffer. */) c n
(int) k
( getsample \() p
(unsigned) k
( ) p
(char) k
( *buffer\)) p n
({) N
(  ) S
(int) k
( tmp=SAMPLE_BUF_SIZE;) p n
(  ) S
(if) K
( \(\(len = read \(audio_fd, buffer, tmp\)\) == -1\) {) p n
(    fprintf\(stderr,") S
(error [\(Duncan\) lstate4.c/get_sample] : Sample failed!\\n) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(if) K
( \(len != SAMPLE_BUF_SIZE\) {) p n
(    fprintf\(stderr,") S
(error [\(Duncan\) lstate4.c/get_sample] : incorrect sample!\\n) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Takes a sample buffer and compresses it ready for sending. */) c n
(void) k
( compress_sample\() p
(unsigned) k
( ) p
(char) k
( *InBuf, ) p
(unsigned) k
( ) p
(char) k
( *OutBuf\)) p n
({) N
(  ) S
(/* Set j to the size of the sample then loop until j becomes zero. */) c n
(  ) p
(int) k
( j=SAMPLE_BUF_SIZE;) p n
(  ) S
(while) K
( \(j--\) {) p n
(    ) S
(/* Run through the Buffers, compressing the sound. */) c n
(    *\(OutBuf++\)=compress\(*\(InBuf\),*\(InBuf+1\)\);) p n
(    InBuf+=2;) N
(  }  ) N
(}) N
() N
() N
(/* Grabs a sample of length SAMPLE_BUF_SIZE into audioIn_Buf,) c n
(   compresses it into serialOut_Buf, then sends the contents) N
(   of serialOut_Buf a byte ata a time to the IDP board.) N
(*/) N
(void) k
( sendSample\() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i=SAMPLE_BUF_SIZE/2;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( t;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( *SBuf=serialOut_Buf;) p n
(  ) N
(#ifdef) K
( DEBUG) p n
(audio_main.c) (Page 4/10) (May 15, 98 4:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/audio_main.c) (11/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (5-6) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  fprintf\(stderr,") p
(Sampling...\\n) str
("\);) p n
(#endif) K n
(  getsample\(audioIn_Buf\);) p n
(  ) N
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr,") S
(Compressing...\\n) str
("\);) p n
(#endif) K n
(  compress_sample\(audioIn_Buf,serialOut_Buf\);) p n
(  ) N
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr,") S
(Sending...\\n) str
("\);) p n
(#endif) K n
(  ) p n
(}) N
() N
() N
() N
(/*) c n
(  Audio Rx routines...) N
(*/) N
(/* Play a sample of length PLAY_BUF_SIZE from buffer. */) N
(int) k
( setsample\() p
(unsigned) k
( ) p
(char) k
( *buffer\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(if) K
( \(\(len = write \(audio_fd, buffer, PLAY_BUF_SIZE\)\) == -1\) {) p n
(    fprintf\(stderr,") S
(error [\(Duncan\) lstate4.c/set_sample] : Sample failed!\\n) str
("\);) p n
(    ) S
(return) K
( -1;) p n
(  }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Decompress a sample. */) c n
(void) k
( decompress_sample\() p
(unsigned) k
( ) p
(char) k
( *InBuf, ) p
(unsigned) k
( ) p
(char) k
( *OutBuf\)) p n
({) N
(  ) S
(int) k
( j=PLAY_BUF_SIZE/2;) p n
(  ) S
(while) K
( \(j--\) {) p n
(    decompress\(*\(InBuf++\),OutBuf\);) N
(    OutBuf+=2;) N
(  }) N
(}) N
() N
() N
(/* ... */) c n
(void) k
( receiveSample\() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(/* We know that there will be precisely half as many compressed samples as) c n
(     there are actual data samples.  Since there is no control info being sent) N
(     to the PC. */) N
(  ) p
(/* ) c n
(     This for-loop has been moved out to l_state10\(\) in order to allow rapid) N
(     state changes.) N
(     ) N
(     for \(i=0;i<PLAY_BUF_SIZE/2;i++\)) N
(     serialIn_Buf[i]=serialreceive\(\);) N
(  */) N
(  ) p
(/* decompress the sample from serialIn_Buf into audioOut_Buf */) c n
(  decompress_sample\(serialIn_Buf,audioOut_Buf\);) p n
(  ) S
(/* Now, play the sample. */) c n
(  setsample\(audioOut_Buf\);) p n
(}) N
() N
(audio_main.c) (Page 5/10) (May 15, 98 4:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/***************************************************************************/) c n
() p n
() N
(void) k
( l_state4\() p
(void) k
(\)) p n
({) N
(  sleep \(2\);) N
(  serialinit\(\);) N
(  ) S
(/* The audio code to send from the PC to the motorola is a bit broken at) c n
(     the moment, consequently this state just waits to be signalled to stop.) N
(     It should be noted that this function's counterpart on the motorola is) N
(     actually fully operational, and that this state just waits for an) N
(     instruction to stop then sends the necessary data to initiate a change-) N
(     state on the motorola.) N
(  */) N
(#ifdef) K
( FULL_AUDIO) p n
(  ) S
(/* Initialise the soundcard and compression routines. */) c n
(  init_audio\(O_RDONLY\);) p n
(  initCompr\(\);) N
(  ) N
(#ifdef) K
( MIXER_TWEAKS) p n
(  ) S
(/*Turn the speakers off and the mic. up. */) c n
(  mixer_volume\(0\);) p n
(  mixer_mic_level\(64\);) N
(#endif) K n
(#ifdef) S
( DEBUG) p n
(  fprintf\(stderr,") S
(lstate4 message : Starting to send audio...\\n) str
("\);) p n
(#endif) K n
(  ) p
(/*Send a start transmission byte to the motorola. */) c n
(  serialtransmit\(0xFE\);) p n
(  ) S
(while) K
( \(Curstate==4\) {) p n
(    sendSample\(\);) N
(    ) S
(for) K
( \(i=0;i<SAMPLE_BUF_SIZE/2;i++\) {) p n
(      ) S
(if) K
( \(Curstate!=4\) ) p
(break) K
(;) p n
(      ) S
(/* enumerates the contents of serialOut_Buf.  If an FF is found in the) c n
() S 8 T ( compressed data, then it is doubled to allow for state changes to be) N
() S 8 T ( sent.) N
(      */) N
(      ) p
(if) K
( \(*SBuf==0xFF\){) p n
() S 8 T (serialtransmit\(0xFF\);) N
(#ifdef) K
( DEBUG) p n
(  ) S 8 T (fprintf\(stderr,") S
(Doubling FF\\n) str
("\);) p n
(#endif) K n
(      }) p n
(      serialtransmit\(*\(SBuf++\)\);) N
(    }) N
(  }) N
(#else) K n
(  ) p n
(  serialtransmit \(0xFF\);) N
(  ) S
(while) K
( \(Curstate==4\)) p n
(    sleep \(10\);) N
(  serialtransmit \(0xFF\);) N
(#endif) K n
(  serialtransmit \(0xFF\);) p n
(  ) N
(  close_audio\(\);) N
(  serialclose\(\);) N
(}) N
() N
() N
() N
(audio_main.c) (Page 6/10) (May 15, 98 4:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/audio_main.c) (12/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (7-8) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( l_state10\() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(S10: starting audio\\n) str
("\);) p n
(#endif) K n
(  ) p n
(  ) S
(/* open soundcard for writing. */) c n
(  init_audio\(O_WRONLY\);) p n
(  ) N
(#ifdef) K
( DEBUG) p n
(  printf \(") S
(S10: Audio initialised.\\nStarting serial...\\n) str
("\);) p n
(#endif) K n
(  ) p n
(  ) S
(/* Wait for serial to become free, and grab it */) c n
(  ) p
(while) K
(\(serialinit\(\)\)) p n
(#ifdef) K
( DEBUG    ) p n
(    printf\(") S
(Trying serial again...\\n) str
("\);) p n
(#endif) K n
(  ) p n
(  ) S
(/* Start the decompression up */) c n
(  initDecompr\(\);) p n
(  ) N
(#ifdef) K
( MIXER_TWEAKS) p n
(  ) S
(/* Turn on the speakers */) c n
(  mixer_volume\(255\);) p n
(  ) S
(/*Turn off the mic. */) c n
(  mixer_mic_level\(0\);) p n
(#endif) K n
(  ) p n
(  ) S
(/* Synch with motorola */) c n
(  serialreceive\(\);) p n
(  ) N
(#ifdef) K
( DEBUG) p n
(  fprintf \(stderr, ") S
(Let's go..\\n) str
("\);) p n
(#endif) K n
(  ) p
(while) K
( \(Curstate==10\) {) p n
(    ) S
(for) K
( \(i=0;i<PLAY_BUF_SIZE/2;i++\) {) p n
(      ) S
(if) K
( \(Curstate!=10\) ) p
(break) K
(;) p n
(      ) N
(      serialIn_Buf[i]=serialreceive\(\);) N
(    }) N
(    ) S
(if) K
( \(Curstate==10\) receiveSample\(\);) p n
(  }) N
(  ) S
(/* Simulate a ping ... */) c n
(  serialtransmit\(1\);) p n
(  ) S
(/* Wait for a ping ack */) c n
(  ) p
(do) K n
(    {) p n
(      ) S
(if) K
( \(serialreceive \(\) != 2\)) p n
() S 8 T () S
(continue) K
(;) p n
(      ) S
(for) K
( \(i = 0; i < 4; i++\)) p n
() S 8 T () S
(if) K
( \(serialreceive \(\) != 0\)) p n
() S 8 T (  ) S
(break) K
(;) p n
(      ) S
(if) K
( \(i == 4\)) p n
() S 8 T () S
(break) K
(;) p n
(    }) N
(  ) S
(while) K
( \(1\);) p n
(  ) N
(  ) S
(/* Shut everything down and leave */) c n
(  close_audio\(\);) p n
(  serialclose\(\);) N
(audio_main.c) (Page 7/10) (May 15, 98 4:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(Done state 10..\\n) str
("\);) p n
(  fflush \(stderr\);) N
(#endif) K n
(}) p n
() N
() N
(/*) c n
(  Opens file fname and plays it to /dev/dsp) N
(*/) N
() p n
(int) k
( play_sample\() p
(char) k
( *fname\) {) p n
(  ) S
(FILE) k
( *SFile;) p n
(  ) S
(int) k
( BufPos=0;) p n
(  ) S
(int) k
( next;) p n
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(Starting audio...\\n) str
("\);) p n
(#endif) K n
(  ) p
(/* open soundcard */) c n
(  init_audio\(O_WRONLY\);) p n
() N
(  ) S
(/*open the file */) c n
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(Opening file '%s'...\\n) str
(",fname\);) p n
(#endif) K n
(  ) p
(if) K
( \(\(SFile = fopen\(fname, ") p
(r) str
("\)\)==) p
(NULL) K
(\) {) p n
(#ifdef) K
( DEBUG) p n
(    fprintf\(stderr, ") S
(Couldn't open file!\\n) str
("\);) p n
(#endif) K n
(    ) p
(return) K
( -1;) p n
(  }) N
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(Playing audio...) str
("\);) p n
(#endif) K n
(  ) p
(while) K
( \(\(next=fgetc\(SFile\)\)!=EOF\) {) p n
(    serialIn_Buf[BufPos++]=\() S
(unsigned) k
( ) p
(char) k
(\) next;) p n
(    ) S
(if) K
( \(!\(BufPos % PLAY_BUF_SIZE\)\) {) p n
(#ifdef) K
( DEBUG) p n
(      fprintf\(stderr, ") S
(.) str
("\);) p n
(#endif) K n
(      setsample\(audioOut_Buf\);) p n
(      BufPos=0;) N
(    }) N
(  }) N
(  ) S
(for) K
( \(BufPos--; BufPos<PLAY_BUF_SIZE; BufPos++\)) p n
(    audioOut_Buf[BufPos]=127;) N
(  setsample\(audioOut_Buf\);) N
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(.\\nShutting down...\\n) str
("\);) p n
(#endif) K n
(  close_audio\(\);) p n
(}) N
() N
() N
(/* Signal handler primarily for communications between GUI and audio) c n
(   processes, but since there is no UI to the audio, it also handles a) N
(   SIGINT - sent by the GUI - which closes the program down.) N
(*/) N
(void) k
( sighandle\() p
(int) k
( s\)) p n
({) N
(#ifdef) K
( DEBUG) p n
(  fprintf\(stderr, ") S
(Signal handler called\\n) str
("\);) p n
(audio_main.c) (Page 8/10) (May 15, 98 4:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/audio_main.c) (13/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (9-10) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#endif) K n
(  ) p
(/*Decide what to do...*/) c n
(  ) p
(switch) K
( \(s\) {) p n
(    ) S
(/*SIGUSR1 has been trapped.) c n
(      This indicates that state 4 is being requested */) N
(  ) p
(case ) K
(SIGUSR1) l
(: ) p n
(    ) S
(switch) K
( \(Curstate\) {) p n
(    ) S
(case ) K
(10) l
(:) p n
(    ) S
(case ) K
(0) l
(: ) p n
(      ) S
(/*Toggle the state to 4 */) c n
(      Curstate = 4;) p n
(      ) S
(break) K
(;) p n
(    ) S
(case ) K
(4) l
(:) p n
(      ) S
(/* Audio is already in state 4 so stop. */) c n
(      Curstate = 0;) p n
(      ) S
(break) K
(;) p n
(    }) N
(    ) S
(break) K
(;) p n
(  ) S
(case ) K
(SIGUSR2) l
(:) p n
(    ) S
(/*SIGUSR2 has been trapped.) c n
(      This indicates that state 10 is being requested */) N
(    ) p
(switch) K
( \(Curstate\) {) p n
(    ) S
(case ) K
(4) l
(:) p n
(    ) S
(case ) K
(0) l
(: ) p n
(      ) S
(/* Toggle state to 4 */) c n
(      Curstate = 10;) p n
(      ) S
(break) K
(;) p n
(    ) S
(case ) K
(10) l
(: ) p n
(      ) S
(/* Audio is already in state 10, so just stop. */) c n
(      Curstate = 0;) p n
(      ) S
(break) K
(;) p n
(    }) N
(    ) S
(break) K
(;) p n
(  ) S
(case ) K
(SIGINT) l
(:) p n
(    ) S
(/* The process is being killed off so exit nicely. */) c n
(    Curstate=-1;) p n
(    ) S
(break) K
(;) p n
(    ) N
(  }) N
(}) N
() N
() N
(void) k
( audio_main \() p
(void) k
(\)) p n
({) N
(  ) S
(struct) k
( sigaction oa;) p n
(  ) S
(/* Set up the signal handler. */) c n
(  signals.sa_handler=sighandle;) p n
(  signals.sa_mask=signals.sa_flags=0;) N
(  signals.sa_restorer=) S
(NULL) K
(;) p n
(  ) N
(  ) S
(/*Register the handler for the 3 signals */) c n
(  sigaction\(SIGUSR1, &signals, &oa\);) p n
(  sigaction\(SIGUSR2, &signals, &oa\);) N
(  sigaction\(SIGINT, &signals, &oa\);) N
(  ) S
(/* When the process starts, the audio should be off. */) c n
(  Curstate=0;) p n
(  ) N
(  ) S
(while) K
( \(Curstate != -1\) {) p n
(    ) S
(switch) K
( \(Curstate\) {) p n
(    ) S
(case ) K
(4) l
(:) p n
(      ) S
(/* The Current state is 4 so call l_state4\(\) */) c n
(      l_state4\(\);) p n
(audio_main.c) (Page 9/10) (May 15, 98 4:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      ) p
(break) K
(;) p n
(    ) S
(case ) K
(10) l
(:) p n
(      ) S
(/* The current state is 10 so call l_state10\(\) */) c n
(      l_state10\(\);) p n
(      ) S
(break) K
(;) p n
(    ) S
(case ) K
(0) l
(:) p n
(      ) S
(/* The audio is off so have a little snooze so that the CPU isn't ) c n
() S 8 T ( bothered by the process.  If a signal is generated by the gui,) N
() S 8 T ( this sleep will exit prematurely and the program will loop again.) N
() S 8 T ( If the audio is not turned on, the program will continue to go to) N
() S 8 T ( sleep for 60 seconds, wake up, go back to sleep...*/) N
(      sleep\(60\);) p n
(      ) S
(break) K
(;) p n
(    }) N
(  };  ) N
(}) N
() N
(audio_main.c) (Page 10/10) (May 15, 98 4:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/audio_main.c) (14/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 15
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* The configuration GUI */) c n
() p n
(#include) K
( <gtk/gtk.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( ") p
(../control/dbm_defs.h) str
(") p n
(#include) K
( <string.h>) p n
(#include) K
( <unistd.h>) p n
(/* need to compile with db_download.c */) c n
() p n
(/* this is our data identification string to store) c n
( * data in list items) N
( */) N
(const) K
(   gchar   *list_item_data_key=") p
(list_item_data) str
(";) p n
() N
(/* database location */) c n
(extern) K
( db_item *database;) p n
() N
(/* GUI globals */) c n
() p n
(GtkWidget *separator,*window,*pinwin,*lvbox,*rvbox,*bbox,) N
(  *scrolled_window, *frame, *gtklist, *cl_button, *add_button,) N
(  *del_button, *fname_entry, *sname_entry, *uid_entry, *last_entry,) N
(  *list_item, *fnm_label, *snm_label, *uid_label, *last_label,) N
(  *master_hbox, *fnamebox, *snamebox, *uidbox, *lastbox, *pinbox,) N
(  *pin_button, *log_button, *pixmapwid, *deptbox, *dept_entry,) N
(  *dp_label, *pvbox, *lok_button,*pin_ok_button, *status_bar,) N
(  *master_vbox, *pin_entry1, *pin_entry2, *pin_vbox, *pin_label,) N
(  *pinbuttonbox, *pin_c_button;) N
() N
(GdkPixmap *pixmap;) N
(GdkBitmap *mask;) N
(GtkStyle *style;) N
() N
(int) k
( context_id,prev_error;) p n
() N
(/* a database record for adding a user */) c n
(db_item add_user_item,final_add_item;) p n
(/* a BOOL flag for adding a user */) c n
(int) k
( adding_user = FALSE; ) p n
(char) k
( pin_1[5];) p n
(char) k
( pin_2[5];) p n
() N
(/* function protypes */) c n
(void) k
( user_selected \(GtkWidget *gtklist,gpointer func_data\);) p n
(void) k
( add_user\( GtkWidget *widget, gpointer *data \);) p n
(void) k
( enter_callback\(GtkWidget *widget, GtkWidget *entry\);) p n
(void) k
( enter_pin\(\);) p n
(void) k
( finished_pin\(GtkWidget *widget, gpointer *data \);) p n
(void) k
( clear_add_item\(\);) p n
(void) k
( create_new_user\(\);) p n
() N
(/* default click handler */) c n
(void) k
( button_clicked\( GtkWidget *widget, gpointer *data \) {) p n
(  printf\( ") S
(button clicked\\n) str
(" \);) p n
(}) N
() N
(/* frees memory and exits */) c n
(void) k
( clean_exit\( GtkWidget *widget, gpointer *data \) {) p n
(  free_database\(\);) N
(  gtk_main_quit\(\);) N
(}) N
() N
(config.c) (Page 1/11) (May 15, 98 9:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* main function to set up the user interface */) c n
(gint main \() p
(int) k
( argc, gchar *argv[]\)) p n
({                                  ) N
() N
(    GList           *dlist;) N
(    guint           i;) N
(    gchar          buffer[64];) N
(    db_item *curr;) N
(    GdkBitmap *mask;) N
(    GtkStyle *style;) N
(    ) N
(    ) S
(/* initialize gtk+ \(and subsequently gdk\) */) c n
() p n
(    gtk_init\(&argc, &argv\);) N
(    ) N
(    ) S
(/* load user database */) c n
(    load_database\(\);) p n
(    curr = database;) N
() N
(    ) S
(/* create a window to put all the widgets in) c n
(     * connect gtk_main_quit\(\) to the "destroy" event of) N
(     * the window to handle window manager close-window-events) N
(     */) N
(    window=gtk_window_new\(GTK_WINDOW_TOPLEVEL\);) p n
(    gtk_window_set_title\(GTK_WINDOW\(window\), ") S
(User Database) str
("\);) p n
(    gtk_signal_connect\(GTK_OBJECT\(window\),) N
() S 8 T () S 16 T (       ") S
(destroy) str
(",) p n
() S 8 T () S 16 T (       GTK_SIGNAL_FUNC\(clean_exit\),) N
() S 8 T () S 16 T (       ) S
(NULL) K
(\);) p n
(    ) S
(/* a master vbox for whole window and status bar */) c n
(    master_vbox = gtk_vbox_new\(FALSE,5\);) p n
(    gtk_container_border_width\(GTK_CONTAINER\(master_vbox\), 5\);) N
(    gtk_container_add\(GTK_CONTAINER\(window\), master_vbox\);    ) N
(    gtk_widget_show\(master_vbox\);) N
() N
() N
(    ) S
(/* a master hbox for whole work area */) c n
(    master_hbox = gtk_hbox_new\(FALSE,5\);) p n
(    gtk_container_border_width\(GTK_CONTAINER\(master_hbox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(master_vbox\), master_hbox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(master_hbox\);) N
() N
(    ) S
(/* create a separator) c n
(     */) N
(    separator=gtk_hseparator_new\(\);) p n
(    gtk_box_pack_start \(GTK_BOX \(master_vbox\), separator, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(separator\);) N
() N
(    ) S
(/**** Left vertical box Widgets ****/) c
(    ) p n
() N
(    ) S
(/* this is the scolled window to put the GtkList widget inside */) c n
(    scrolled_window=gtk_scrolled_window_new\() p
(NULL) K
(, ) p
(NULL) K
(\);) p n
(    gtk_widget_set_usize\(scrolled_window, 250, 150\);) N
(    gtk_container_add\(GTK_CONTAINER\(master_hbox\), scrolled_window\);) N
(    gtk_widget_show\(scrolled_window\);) N
(    ) N
(    ) S
(/* create the GtkList widget) c n
(     * connect the sigh_print_selection\(\) signal handler) N
(     * function to the "selection_changed" signal of the GtkList) N
(     * to print out the selected items each time the selection) N
(     * has changed */) N
(    gtklist=gtk_list_new\(\);) p n
(config.c) (Page 2/11) (May 15, 98 9:21) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/config.c) (15/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3-4) 16
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    gtk_container_add\(GTK_CONTAINER\(scrolled_window\), gtklist\);) p n
(    gtk_widget_show\(gtklist\);) N
(    gtk_signal_connect\(GTK_OBJECT\(gtklist\),) N
() S 8 T () S 16 T (       ") S
(selection_changed) str
(",) p n
() S 8 T () S 16 T (       GTK_SIGNAL_FUNC\(user_selected\),) N
() S 8 T () S 16 T (       ) S
(NULL) K
(\);) p n
(    ) N
(    ) S
(/* now we create 5 list items, each having it\264s own) c n
(     * label and add them to the GtkList using gtk_container_add\(\)) N
(     * also we query the text string from the label and) N
(     * associate it with the list_item_data_key for each list item) N
(     */) N
() p n
(    ) S
(while) K
(\(curr\){) p n
(      GtkWidget       *label;) N
(      gchar           *string;) N
(      ) S
(char) k
( name[60];) p n
() N
(      sprintf\(name,") S
(%s %s) str
(",curr->fname,curr->sname\);) p n
(      label=gtk_label_new\(name\);) N
(      list_item=gtk_list_item_new\(\);) N
(      gtk_container_add\(GTK_CONTAINER\(list_item\), label\);) N
(      gtk_widget_show\(label\);) N
(      gtk_container_add\(GTK_CONTAINER\(gtklist\), list_item\);) N
(      gtk_widget_show\(list_item\);) N
(      gtk_label_get\(GTK_LABEL\(label\), &string\);) N
(      gtk_object_set_data\(GTK_OBJECT\(list_item\),) N
() S 8 T () S 16 T () S 24 T (    list_item_data_key,) N
() S 8 T () S 16 T () S 24 T (    string\);) N
(      curr = curr->next;) N
(    }) N
() N
(    ) S
(/* Operation buttons */) c n
(    bbox=gtk_hbox_new\(FALSE, 5\);) p n
(    gtk_container_border_width\(GTK_CONTAINER\(bbox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(master_vbox\), bbox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(bbox\);) N
() N
() N
(    add_button=gtk_button_new_with_label\(") S
(Add) str
("\);) p n
(    gtk_widget_show\(add_button\);) N
(    gtk_box_pack_start \(GTK_BOX \(bbox\), add_button, TRUE, TRUE, TRUE\);) N
(    gtk_signal_connect_object\(GTK_OBJECT\(add_button\),) N
() S 8 T () S 16 T () S 24 T (      ") S
(clicked) str
(",) p n
() S 8 T () S 16 T () S 24 T (      GTK_SIGNAL_FUNC\(add_user\),) N
() S 8 T () S 16 T () S 24 T (      GTK_OBJECT\(window\)\);) N
() N
(    del_button=gtk_button_new_with_label\(") S
(Delete) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(bbox\), del_button, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(del_button\);) N
() N
(    ) S
(/* pin button */) c n
() p n
(    pin_button=gtk_button_new_with_label\(") S
(Change PIN) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(bbox\), pin_button, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(pin_button\);) N
() N
(    ) S
(/*gtk_signal_connect_object\(GTK_OBJECT\(pin_button\),) c n
() S 8 T () S 16 T () S 24 T (      "clicked",) N
() S 8 T () S 16 T () S 24 T (      GTK_SIGNAL_FUNC\(gtk_widget_destroy\),) N
() S 8 T () S 16 T () S 24 T (      GTK_OBJECT\(window\)\);*/) N
() p n
(config.c) (Page 3/11) (May 15, 98 9:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(/*log_button=gtk_button_new_with_label\("View Log"\);) c n
(    gtk_widget_show\(log_button\);) N
(    gtk_box_pack_start \(GTK_BOX \(bbox\), log_button, TRUE, TRUE, TRUE\);) N
(    gtk_signal_connect_object\(GTK_OBJECT\(log_button\),) N
() S 8 T () S 16 T () S 24 T (      "clicked",) N
() S 8 T () S 16 T () S 24 T (      GTK_SIGNAL_FUNC\(gtk_widget_destroy\),) N
() S 8 T () S 16 T () S 24 T (      GTK_OBJECT\(window\)\);*/) N
() p n
(      ) S
(/* finally create a button and connect it\264s "clicked" signal) c n
(     * to the destroyment of the window) N
(     */) N
(    cl_button=gtk_button_new_with_label\(") p
(Close) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(bbox\), cl_button, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(cl_button\);) N
(    gtk_signal_connect_object\(GTK_OBJECT\(cl_button\),) N
() S 8 T () S 16 T () S 24 T (      ") S
(clicked) str
(",) p n
() S 8 T () S 16 T () S 24 T (      GTK_SIGNAL_FUNC\(clean_exit\),) N
() S 8 T () S 16 T () S 24 T (      GTK_OBJECT\(window\)\);) N
() N
(    ) S
(/**** Right hand side ****/) c n
() p n
(    rvbox=gtk_vbox_new\(FALSE, 5\);) N
(    gtk_container_border_width\(GTK_CONTAINER\(rvbox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(master_hbox\), rvbox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(rvbox\);) N
() N
() N
(    ) S
(/** SName box **/) c n
() p n
(    snamebox=gtk_hbox_new\(FALSE, 5\);) N
(    gtk_container_border_width\(GTK_CONTAINER\(snamebox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(rvbox\), snamebox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(snamebox\);) N
() N
() N
(    ) S
(/* entry 2 */) c n
(    snm_label = gtk_label_new \(") p
(Surname) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(snamebox\), snm_label, TRUE, TRUE, 0\);) N
(    gtk_widget_show\(snm_label\);) N
() N
(    ) S
(/* entry */) c n
(    sname_entry = gtk_entry_new_with_max_length \(50\);) p n
(    gtk_signal_connect\(GTK_OBJECT\(sname_entry\), ") S
(changed) str
(",) p n
() S 8 T () S 16 T (       GTK_SIGNAL_FUNC\(enter_callback\),) N
() S 8 T () S 16 T (       sname_entry\);) N
(    gtk_box_pack_start \(GTK_BOX \(snamebox\), sname_entry, TRUE, TRUE, 0\);) N
(    gtk_entry_set_editable \(sname_entry,FALSE\);) N
(    gtk_widget_show \(sname_entry\);) N
(    ) S
(/** FName box **/) c n
() p n
(    fnamebox=gtk_hbox_new\(FALSE, 5\);) N
(    gtk_container_border_width\(GTK_CONTAINER\(fnamebox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(rvbox\), fnamebox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(fnamebox\);) N
() N
(    ) S
(/* label */) c n
() p n
(    fnm_label = gtk_label_new \(") S
(Forename) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(fnamebox\), fnm_label, TRUE, TRUE, 0\);) N
(    gtk_widget_show\(fnm_label\);) N
() N
(    ) S
(/* entry */) c n
(config.c) (Page 4/11) (May 15, 98 9:21) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/config.c) (16/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (5-6) 17
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    fname_entry = gtk_entry_new_with_max_length \(50\);) p n
(    gtk_signal_connect\(GTK_OBJECT\(fname_entry\), ") S
(changed) str
(",) p n
() S 8 T () S 16 T (       GTK_SIGNAL_FUNC\(enter_callback\),) N
() S 8 T () S 16 T (       fname_entry\);) N
(    gtk_box_pack_start \(GTK_BOX \(fnamebox\), fname_entry, TRUE, TRUE, 0\);) N
(    gtk_entry_set_editable \(fname_entry,FALSE\);) N
(    gtk_widget_show \(fname_entry\);) N
(    ) N
() N
(    ) S
(/** Department box **/) c n
() p n
(    deptbox=gtk_hbox_new\(FALSE, 5\);) N
(    gtk_container_border_width\(GTK_CONTAINER\(deptbox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(rvbox\), deptbox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(deptbox\);) N
() N
(    ) S
(/* label */) c n
() p n
(    dp_label = gtk_label_new \(") S
(Department) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(deptbox\), dp_label, TRUE, TRUE, 0\);) N
(    gtk_widget_show\(dp_label\);) N
() N
(    ) S
(/* entry */) c n
(    dept_entry = gtk_entry_new_with_max_length \(50\);) p n
(    gtk_signal_connect\(GTK_OBJECT\(dept_entry\), ") S
(changed) str
(",) p n
() S 8 T () S 16 T (       GTK_SIGNAL_FUNC\(enter_callback\),) N
() S 8 T () S 16 T (       dept_entry\);) N
(    gtk_box_pack_start \(GTK_BOX \(deptbox\), dept_entry, TRUE, TRUE, 0\);) N
(    gtk_entry_set_editable \(dept_entry,FALSE\);) N
(    gtk_widget_show \(dept_entry\);) N
(    ) N
(    ) S
(/** UID box **/) c n
() p n
(    uidbox=gtk_hbox_new\(FALSE, 5\);) N
(    gtk_container_border_width\(GTK_CONTAINER\(uidbox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(rvbox\), uidbox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(uidbox\);) N
() N
(    ) S
(/* label */) c n
() p n
(    uid_label = gtk_label_new \(") S
(ID Number) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(uidbox\), uid_label, TRUE, TRUE, 0\);) N
(    gtk_widget_show\(uid_label\);) N
() N
(    ) S
(/* entry */) c n
(    uid_entry = gtk_entry_new_with_max_length \(12\);) p n
(    gtk_signal_connect\(GTK_OBJECT\(uid_entry\), ") S
(changed) str
(",) p n
() S 8 T () S 16 T (       GTK_SIGNAL_FUNC\(enter_callback\),) N
() S 8 T () S 16 T (       uid_entry\);) N
(    gtk_box_pack_start \(GTK_BOX \(uidbox\), uid_entry, TRUE, TRUE, 0\);) N
(    gtk_entry_set_editable \(uid_entry,FALSE\);    ) N
(    gtk_widget_show \(uid_entry\);) N
(    ) N
(    ) S
(/** last entry box **/) c n
() p n
(    lastbox=gtk_hbox_new\(FALSE, 5\);) N
(    gtk_container_border_width\(GTK_CONTAINER\(lastbox\), 5\);) N
(    gtk_box_pack_start \(GTK_BOX \(rvbox\), lastbox, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(lastbox\);) N
() N
(    ) S
(/* label */) c n
() p n
(config.c) (Page 5/11) (May 15, 98 9:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    last_label = gtk_label_new \(") p
(Last Entry) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(lastbox\), last_label, TRUE, TRUE, 0\);) N
(    gtk_widget_show\(last_label\);) N
() N
(    ) S
(/* entry */) c n
(    last_entry = gtk_entry_new_with_max_length \(50\);) p n
(    gtk_box_pack_start \(GTK_BOX \(lastbox\), last_entry, TRUE, TRUE, 0\);) N
(    gtk_entry_set_editable \(last_entry,FALSE\);) N
(    gtk_widget_show \(last_entry\); ) N
() N
(    ) S
(/* the lockout check button */) c n
() p n
(    lok_button=gtk_check_button_new_with_label\(") S
(User lockout) str
("\);) p n
(    gtk_box_pack_start \(GTK_BOX \(rvbox\), lok_button, TRUE, TRUE, TRUE\);) N
(    gtk_widget_show\(lok_button\);) N
(    gtk_signal_connect_object\(GTK_OBJECT\(lok_button\),) N
() S 8 T () S 16 T () S 24 T (      ") S
(clicked) str
(",) p n
() S 8 T () S 16 T () S 24 T (      GTK_SIGNAL_FUNC\(button_clicked\),) N
() S 8 T () S 16 T () S 24 T (      GTK_OBJECT\(window\)\);) N
() N
(    ) S
(/* a status bar */) c n
(    status_bar = gtk_statusbar_new\(\);      ) p n
(    gtk_box_pack_start \(GTK_BOX \(master_vbox\), status_bar, TRUE, TRUE, 0\);) N
(    gtk_widget_show \(status_bar\);) N
() N
(    context_id = gtk_statusbar_get_context_id\() N
() S 8 T (GTK_STATUSBAR\(status_bar\), ") S
(Normal) str
("\);) p n
(        gtk_statusbar_push\(status_bar,context_id,) N
() S 8 T () S 16 T () S 24 T (   ") S
(Click a user to see details.) str
("\);) p n
() N
() S 8 T () S
(/* finaly we want to see the window */) c n
(    gtk_widget_show\(window\);) p n
(    ) N
(    ) S
(/* fire up the main event loop of gtk) c n
(     */) N
(    gtk_main\(\);) p n
(    ) N
(    ) S
(/* we get here after gtk_main_quit\(\) has been called which) c n
(     * happens if the main window gets destroyed) N
(     */) N
(    ) p
(return) K
( 0;) p n
(}) N
() N
() N
(/* Called if a user is selected. Opens a user properties window */) c n
() p n
(void) k
( user_selected \(GtkWidget *gtklist,gpointer func_data\)) p n
({) N
(  GtkObject       *list_item;) N
(  gchar           *item_data_string;) N
(  GList   *dlist;) N
(  db_item *item;) N
() N
(  ) S
(if) K
(\(!adding_user\){) p n
(    ) S
(/* fetch the doubly linked list of selected items) c n
(     * of the GtkList, remember to treat this as read-only!) N
(     */) N
(    dlist=GTK_LIST\(gtklist\)->selection;) p n
(    ) N
(    ) S
(/* if there are no selected items there is nothing more) c n
(     * to do than just telling the user so) N
(     */) N
(config.c) (Page 6/11) (May 15, 98 9:21) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/config.c) (17/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (7-8) 18
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(if) K
( \(!dlist\) {) p n
(      g_print\(") S
(Selection cleared\\n) str
("\);) p n
(      ) S
(return) K
(;) p n
(    }) N
(    ) S
(/* ok, we got a selection and so we print it) c n
(     */) N
(    ) p n
(    ) S
(/* get the list item from the doubly linked list) c n
(     * and then query the data associated with list_item_data_key) N
(     * we then just print it) N
(   */) N
(    list_item=GTK_OBJECT\(dlist->data\);) p n
(    item_data_string=gtk_object_get_data\(list_item,) N
() S 8 T () S 16 T () S 24 T () S 32 T (       list_item_data_key\);) N
(    item = get_db_item\(item_data_string\);) N
(    ) N
(    ) S
(if) K
(\(item\){) p n
(      gtk_entry_set_text \(GTK_ENTRY \(sname_entry\),item->sname\);) N
(      gtk_entry_set_text \(GTK_ENTRY \(fname_entry\),item->fname\);) N
(      gtk_entry_set_text \(GTK_ENTRY \(dept_entry\),item->dept\);) N
(      gtk_entry_set_text \(GTK_ENTRY \(uid_entry\),item->uid\);) N
(      ) S
(if) K
(\(item->lock == ') p
(L) str
('\) gtk_toggle_button_set_state \(lok_button,TRUE\);) p n
(      ) S
(else) K
( gtk_toggle_button_set_state\(lok_button,FALSE\);) p n
(      ) N
(      printf\(") S
(%s\\n) str
(",item->photo\);) p n
(  }) N
(  ) S
(else) K
( printf\(") p
(Data record not found\\n) str
("\);) p n
(  }) N
(}  ) N
() N
(void) k
( add_user\( GtkWidget *widget, gpointer *data \) {) p n
() N
(  ) S
(if) K
(\(adding_user == FALSE\) adding_user = TRUE;) p n
(  ) S
(else) K
( ) p
(if) K
(\(strlen\(add_user_item.uid\) == 12\){ ) p n
(    ) S
(/* copy the text entries into "final" buffer */) c n
(    strcpy\(final_add_item.sname,add_user_item.sname\);) p n
(    strcpy\(final_add_item.fname,add_user_item.fname\);) N
(    strcpy\(final_add_item.uid,add_user_item.uid\);) N
(    strcpy\(final_add_item.dept,add_user_item.dept\);) N
(    ) S
(/* open an enter pin requester */) c n
(    enter_pin\(\);) p n
(  }) N
(  ) S
(else) K
( {) p n
(      gtk_statusbar_push\(status_bar,context_id,) N
() S 8 T (") S
(Serial number must be 12 digits, as shown on your iButton) str
("\);) p n
(      prev_error = TRUE;) N
(      ) S
(return) K
(;) p n
(  }) N
() N
(  gtk_window_set_title\(window,") S
(User Database - Add User) str
("\);) p n
(  ) N
(  gtk_entry_set_text \(GTK_ENTRY \(sname_entry\), ""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(fname_entry\), ""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(uid_entry\), ""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(dept_entry\), ""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(last_entry\), ") S
(--/--/--) str
("\);) p n
(  ) N
(  gtk_entry_set_editable \(sname_entry,TRUE\);) N
(  gtk_entry_set_editable \(fname_entry,TRUE\);) N
(  gtk_entry_set_editable \(uid_entry,TRUE\);) N
(  gtk_entry_set_editable \(dept_entry,TRUE\);) N
() N
(config.c) (Page 7/11) (May 15, 98 9:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  gtk_statusbar_push\(status_bar,context_id,) p n
() S 8 T () S 16 T (      ") S
(Fill in the text fields. Click Add again to finish) str
("\);) p n
(}) N
() N
(/* callback function for all entry widgets */) c n
(void) k
( enter_callback\(GtkWidget *widget, GtkWidget *entry\)) p n
({) N
(  gchar *entry_text;) N
(  entry_text = gtk_entry_get_text\(GTK_ENTRY\(entry\)\);) N
() N
(  ) S
(if) K
(\(prev_error\){   ) p n
(    gtk_statusbar_pop\(status_bar,context_id\);) N
(    prev_error = FALSE;) N
(  }) N
(  ) S
(/* surname */) c n
(  ) p
(if) K
(\(widget == sname_entry\) {) p n
(    strcpy\(add_user_item.sname,entry_text\);) N
(  }) N
(  ) S
(/* forename */) c n
(  ) p
(if) K
(\(widget == fname_entry\) strcpy\(add_user_item.fname,entry_text\);) p n
(  ) S
(if) K
(\(widget == uid_entry\) {) p n
(    strcpy\(add_user_item.uid,entry_text\);) N
(  }) N
(  ) S
(if) K
(\(widget == dept_entry\) strcpy\(add_user_item.dept,entry_text\);) p n
(  ) S
(if) K
(\(widget == pin_entry1\) strcpy\(pin_1,entry_text\);) p n
(  ) S
(if) K
(\(widget == pin_entry2\) strcpy\(pin_2,entry_text\);) p n
(}) N
() N
(/* PIN entry dialog box */) c n
(void) k
( enter_pin\(\)) p n
({) N
(  pinwin=gtk_window_new\(GTK_WINDOW_TOPLEVEL\);) N
(  gtk_window_set_title\(GTK_WINDOW\(pinwin\), ") S
(PIN Entry) str
("\);) p n
() N
(  gtk_widget_show\(pinwin\);) N
() N
(  pin_vbox=gtk_vbox_new\(FALSE, 5\);) N
(  gtk_container_border_width\(GTK_CONTAINER\(pin_vbox\), 5\);) N
(  gtk_container_add\(GTK_CONTAINER\(pinwin\), pin_vbox\);    ) N
(  gtk_widget_show\(pin_vbox\);) N
() N
(  ) S
(/* Text */) c n
(  pin_label = gtk_label_new \(") p
(Enter your 4-digit pin in each box) str
("\);) p n
(  gtk_box_pack_start \(GTK_BOX \(pin_vbox\), pin_label, TRUE, TRUE, 0\);) N
(  gtk_widget_show\(pin_label\);) N
() N
(  ) S
(/* entry */) c n
(  pin_entry1 = gtk_entry_new_with_max_length \(4\);) p n
(  gtk_signal_connect\(GTK_OBJECT\(pin_entry1\), ") S
(changed) str
(",) p n
() S 8 T () S 16 T (     GTK_SIGNAL_FUNC\(enter_callback\),) N
() S 8 T () S 16 T (       pin_entry1\);) N
(  gtk_box_pack_start \(GTK_BOX \(pin_vbox\), pin_entry1, TRUE, TRUE, 0\);) N
(  gtk_entry_set_visibility \(pin_entry1,FALSE\);) N
(  gtk_widget_show \(pin_entry1\); ) N
(  ) N
(  ) S
(/* entry */) c n
(  pin_entry2 = gtk_entry_new_with_max_length \(4\);) p n
(  gtk_signal_connect\(GTK_OBJECT\(pin_entry2\), ") S
(changed) str
(",) p n
() S 8 T () S 16 T (     GTK_SIGNAL_FUNC\(enter_callback\),) N
() S 8 T () S 16 T (       pin_entry2\);) N
(  gtk_box_pack_start \(GTK_BOX \(pin_vbox\), pin_entry2, TRUE, TRUE, 0\);) N
(  gtk_entry_set_visibility \(pin_entry2,FALSE\);) N
(config.c) (Page 8/11) (May 15, 98 9:21) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/config.c) (18/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (9-10) 19
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  gtk_widget_show \(pin_entry2\); ) p n
() N
(  ) S
(/* hbox */) c n
(  pinbuttonbox=gtk_hbox_new\(FALSE, 5\); ) p n
(  gtk_container_border_width\(GTK_CONTAINER\(pinbuttonbox\), 5\);) N
(  gtk_box_pack_start \(GTK_BOX \(pin_vbox\), pinbuttonbox, FALSE, FALSE, TRUE\);) N
(  gtk_widget_show\(pinbuttonbox\);) N
() N
(  ) S
(/* OK button */) c n
(  ) p n
(  pin_ok_button=gtk_button_new_with_label\(") S
(OK) str
("\);) p n
(  gtk_box_pack_start \(GTK_BOX \(pinbuttonbox\), pin_ok_button, TRUE, TRUE, TRUE\);) N
(  gtk_widget_show\(pin_ok_button\);) N
(  gtk_signal_connect_object\(GTK_OBJECT\(pin_ok_button\),) N
() S 8 T () S 16 T () S 24 T (    ") S
(clicked) str
(",) p n
() S 8 T () S 16 T () S 24 T (    GTK_SIGNAL_FUNC\(finished_pin\),) N
() S 8 T () S 16 T () S 24 T (    GTK_OBJECT\(pin_ok_button\)\);) N
(  gtk_widget_show \(pin_ok_button\); ) N
(  ) N
( ) N
(  ) S
(/* Cancel button */) c n
(  ) p n
(  pin_c_button=gtk_button_new_with_label\(") S
(Cancel) str
("\);) p n
(  gtk_box_pack_start \(GTK_BOX \(pinbuttonbox\), pin_c_button, TRUE, TRUE, TRUE\);) N
(  gtk_widget_show\(pin_c_button\);) N
(  gtk_signal_connect_object\(GTK_OBJECT\(pin_c_button\),) N
() S 8 T () S 16 T () S 24 T (    ") S
(clicked) str
(",) p n
() S 8 T () S 16 T () S 24 T (    GTK_SIGNAL_FUNC\(finished_pin\),) N
() S 8 T () S 16 T () S 24 T (    GTK_OBJECT\(pin_c_button\)\);) N
(  gtk_widget_show \(pin_c_button\); ) N
(  ) N
(}) N
() N
(/* validates PIN */) c n
(void) k
( finished_pin\(GtkWidget *widget, gpointer *data \)) p n
({) N
(  ) S
(char) k
( status_text[100];) p n
(  printf\(") S
(Entered finished pin. %s\\n) str
(",add_user_item.sname\);) p n
(  ) S
(/* To Do: check whether PIN entries are equal and valid. Save in) c n
(     global struct, and add user to linked list in memory, in a sorted) N
(     position. Flag a changed database. The whole thing is resaved on) N
(     exit of program */) N
() p n
(  ) S
(/* If cancel is pressed, clear input vars etc */) c n
(  ) p
(if) K
(\(widget == pin_c_button\){) p n
(    gtk_statusbar_push\(status_bar,context_id,") S
(Add user cancelled) str
("\);) p n
(    clear_add_item\(\);) N
() N
(    adding_user = FALSE;) N
(    gtk_object_destroy\(pinwin\);) N
(  }) N
(  ) S
(else) K
( ) p
(if) K
(\(widget == pin_ok_button\){) p n
(    ) S
(/* check that pins are the same and 4 chars long */) c n
(    ) p
(if) K
(\(strcmp\(pin_1,pin_2\) == 0 &&) p n
(       strlen\(pin_1\) == 4 && strlen\(pin_2\) == 4\){) N
(      ) S
(/* PIN OK */) c n
(      printf\(") p
(%s %s\\n) str
(",final_add_item.fname,add_user_item.sname\);) p n
(      adding_user = FALSE;) N
(      sprintf\(status_text,") S
(%s %s has been added to the user database.) str
(",) p n
() S 8 T (      final_add_item.fname,final_add_item.sname\);) N
(      gtk_statusbar_push\(status_bar,context_id,status_text\);) N
(      gtk_object_destroy\(pinwin\);      ) N
(config.c) (Page 9/11) (May 15, 98 9:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      gtk_window_set_title\(window,") p
(User Database) str
("\);) p n
(      create_new_user\(\);) N
(    }) N
(    ) S
(else) K
( {) p n
(      ) S
(/* PIN entries different */) c n
(      gtk_statusbar_push\(status_bar,context_id,) p n
() S 8 T () S 16 T () S 24 T ( ") S
(You must enter the same 4-digit PIN twice) str
("\);) p n
(      gtk_entry_set_text \(GTK_ENTRY \(pin_entry1\),""\);) N
(      gtk_entry_set_text \(GTK_ENTRY \(pin_entry2\),""\);) N
(    }) N
(  }) N
(} ) N
(      ) N
(/* resets entry widgets to no string */) c n
(void) k
( clear_add_item\(\)) p n
({) N
(  add_user_item.sname[0] = ') S
(\\0) str
(';) p n
(  add_user_item.fname[0] = ') S
(\\0) str
(';) p n
(  add_user_item.dept[0] = ') S
(\\0) str
(';) p n
(  add_user_item.uid[0] = ') S
(\\0) str
(';) p n
(  gtk_entry_set_text \(GTK_ENTRY \(sname_entry\),""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(fname_entry\),""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(uid_entry\),""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(dept_entry\),""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(pin_entry1\),""\);) N
(  gtk_entry_set_text \(GTK_ENTRY \(pin_entry2\),""\);) N
(}) N
() N
(/* Allocates memory for user record, copies data and links it into the) c n
( * list. Also adds it to the GUI scrolled list.) N
( */) N
() p n
(void) k
( create_new_user\(\)) p n
({) N
(  db_item *new_item,*prev, *curr = database, *temp;) N
(  ) S
(int) k
( listpos=0;) p n
(  GtkObject *list_item;) N
(  gchar *item_data_string;) N
(  GList *dlist;) N
(  ) S
(char) k
( name[60];) p n
(  GtkWidget       *label;) N
() N
(  new_item = \(db_item *\)malloc\() S
(sizeof) K
(\(db_item\)\);) p n
() N
(  strcpy\(new_item->uid,final_add_item.uid\);) N
(  strcpy\(new_item->pin,pin_1\);) N
(  strcpy\(new_item->fname,final_add_item.fname\);) N
(  strcpy\(new_item->sname,final_add_item.sname\);) N
(  strcpy\(new_item->dept,final_add_item.dept\);) N
(  strcpy\(new_item->photo,") S
(%) str
("\);) p n
(  new_item->lock = ') S
(N) str
(';) p n
(  new_item->next = ) S
(NULL) K
(;) p n
(  printf\(") S
(Created new user %s\\n) str
(",new_item->sname\);) p n
(  ) N
(  curr = database;) N
(  printf\(") S
(first name: %s\\n) str
(",database->sname\);) p n
() N
(  ) S
(/* find insertion point */) c n
(  ) p
(while) K
(\(curr!=) p
(NULL) K
(\){ ) p n
(    ) S
(int) k
( r;) p n
(    r = strcmp\(new_item->sname,curr->sname\);) N
(    ) S
(if) K
(\(r < 0\) ) p
(break) K
(;) p n
(config.c) (Page 10/11) (May 15, 98 9:21) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/config.c) (19/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (11,1) 20
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(else) K
( {) p n
(      printf\(") S
(compared %s: %i\\n) str
(",curr->sname,r\);) p n
(      prev = curr;) N
(      curr = curr->next;) N
(      listpos++; ) S
(/* so we know were to insert in GUI list */) c n
(    }) p n
(  }) N
(  printf\(") S
(Inserting in position %i\\n) str
(",listpos\);) p n
(  ) N
(  ) S
(/* when we find it, insert it! */) c n
(  ) p
(if) K
(\(listpos == 0\){) p n
(    temp = database;) N
(    database = new_item;) N
(    new_item->next = temp;) N
(  } ) S
(else) K
( {) p n
(    temp = prev -> next;) N
(    prev->next = new_item;) N
(    new_item->next = temp;) N
(  }) N
(  ) N
(  ) N
(  ) S
(/* print out list */) c n
(  curr = database;) p n
(  ) S
(while) K
(\(curr\){) p n
(    printf\(") S
(%s %s %s\\n) str
(",curr->fname,curr->sname,curr->uid\);) p n
(    curr = curr->next;) N
(  }) N
(  ) N
(  ) S
(/* add into GUI list */) c n
(  ) p n
(  sprintf\(name,") S
(%s %s) str
(",new_item->fname,new_item->sname\);) p n
(  label=gtk_label_new\(name\);) N
(  list_item=gtk_list_item_new\(\);) N
(  gtk_container_add\(GTK_CONTAINER\(list_item\), label\);) N
(  gtk_widget_show\(label\);) N
(  gtk_container_add\(GTK_CONTAINER\(gtklist\), list_item\);) N
(  gtk_widget_show\(list_item\);) N
(  gtk_label_get\(GTK_LABEL\(label\), name\);) N
(  gtk_object_set_data\(GTK_OBJECT\(list_item\),) N
() S 8 T () S 16 T (      list_item_data_key,) N
() S 8 T () S 16 T (      name\);) N
(}) N
(config.c) (Page 11/11) (May 15, 98 9:21) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Functions for database download \(Linux\) via serial line.) c n
( * Edward Knowelden ) N
( */) N
() p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( ") p
(../dbm_defs.h) str
(") p n
() N
(extern) K
( ) p
(int) k
( itos\() p
(int) k
(,) p
(char) k
( *,) p
(int) k
(\);) p n
(extern) K
( db_item *database;) p n
(int) k
( dbdl_done = FALSE,next_flag = FALSE;) p n
() N
(/* database buffer */) c n
(extern) K
( db_item db_store[MAX_USERS];) p n
() N
(int) k
( db_download\(\)) p n
({) N
(  packet dload,*next;) N
(  ) S
(int) k
( load_result, success;) p n
(  db_item *curr;) N
(  local_db_item send_item;) N
(  ) S
(int) k
( sent = 0; ) p n
(  ) S
(char) k
( eof = 0xFF;) p n
(  ) N
(  printf\(") S
(Starting DB download\\n) str
("\);) p n
(  load_result = load_database\(\);) N
(  ) S
(if) K
(\(load_result == 0\) {) p n
(    printf\(") S
(Download problem) str
("\);) p n
(    exit\(1\);) N
(  }) N
(  curr = database;) N
(  ) N
(  dload.datatype = \(datatype_t\)DATABASE;) N
(  dload.length = ) S
(sizeof) K
(\(local_db_item\);) p n
(  ) N
(  ) S
(while) K
(\(curr != ) p
(NULL) K
(\){) p n
(    strcpy\(send_item.uid,curr->uid\);) N
(    strcpy\(send_item.pin,curr->pin\);) N
(    ) N
(    dload.data = \() S
(char) k
( *\)&send_item;) p n
(    success = senddata\(&dload\);) N
(    printf\(") S
(Sent %s. Size %i\\n) str
(",send_item.uid,dload.length\);) p n
(    curr = curr->next;) N
(    sent += ) S
(sizeof) K
(\(db_item\);) p n
(    ) N
(    ) S
(/* wait for sync signal */) c n
(    printf\(") p
(Waiting for next flag\\n) str
("\);) p n
(    ) S
(while) K
(\(!next_flag\)) p n
(      sleep\(5\);) N
(    next_flag = FALSE;) N
(    printf\(") S
(Got next flag\\n) str
("\);) p n
(  }    ) N
(    ) S
(/* send an EOF packet */) c n
(    dload.length = ) p
(sizeof) K
(\() p
(char) k
(\);) p n
(    dload.data = &eof;) N
(    senddata\(&dload\);) N
(    printf\(") S
(sent EOF\\n) str
("\);) p n
(    ) N
(    printf\(") S
(Finished. Sent %i bytes\\n) str
(",sent\);) p n
(}) N
() N
(  ) N
(db_download.c) (Page 1/2) (May 15, 98 8:57) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/config.c, linux/db_download.c) (20/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2,1) 21
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* Handle CONTROL packets received by SERIAL_TRANSPORT */) c n
(void) k
( handle_control_data\(packet *p\)) p n
({) N
(  ) S
(int) k
( message_type;) p n
(  ) S
(/* set 'done' flag \(for testing\) */) c n
(  dbdl_done = TRUE;) p n
() N
(  printf\(") S
(Called handle_control_data\\n) str
("\);) p n
(  ) S
(/* find type of message */) c n
(  message_type = atoi\(p->data\);) p n
(  ) N
(  ) S
(if) K
(\(message_type == REQUEST_NEXT\) {) p n
(    printf\(") S
(next flag = %i\\n) str
(",next_flag\);) p n
(    next_flag = TRUE;) N
(  }) N
(  ) S
(if) K
(\(message_type == REQUEST_DBDL\) db_download\(\);) p n
(} ) N
() N
() N
(db_download.c) (Page 2/2) (May 15, 98 8:57) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* gui.c */) c n
(/* Edward Knowelden */) N
() p n
(/* Signals to audio process) c n
(SIGUSER1 : Linux to Motorola \(TALK\)) N
(SIGUSER2 : Motorola to Linux \(LISTEN\)) N
(SIGUSER1/2 sent while its corresponding direction is active stops audio.) N
(*/) N
() p n
(#include) K
( <gtk/gtk.h>) p n
(#include) K
( <string.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <signal.h>) p n
(#include) K
( <stdlib.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <serial.h>) p n
(#include) K
( <control.h>) p n
(#include) K
( <data.h>) p n
(#include) K
( ") p
(xpm.h) str
(") p n
() N
(void) k
( init_gui\() p
(int) k
( argc, ) p
(char) k
( *argv[]\);) p n
(void) k
( get_new_image\( GtkWidget *widget, gpointer *data\);) p n
(extern) K
( ) p
(int) k
( itos\() p
(int) k
( num,) p
(char) k
( *result,) p
(int) k
( mlength\);) p n
(void) k
( handle_control\(packet *p\);) p n
(void) k
( show_buttons\(\);) p n
(void) k
( hide_buttons\(\);) p n
() N
(/* globals */) c n
() p n
(extern) K
( ) p
(int) k
( audio_pid;) p n
(int) k
( audio_state;) p n
() N
(/* flag to stop 'auto' toggle button clicks */) c n
(int) k
( no_clicks = TRUE;) p n
() N
(GtkWidget *window, *pixmapwid, *button1, *button2, *rc_button,) N
(  *cl_button, *cf_button, *au_button, *tk_button, *ls_button,*lbox,) N
(  *button_box, *rbox, *box, *bellwin, *separator, *radiobox, *button,) N
(  *group,*rbutton1,*rbutton2,*status_bar,*master_box;) N
() N
(GdkPixmap *pixmap;) N
(GdkBitmap *mask;) N
(GtkStyle *style;) N
(GtkTooltips *cf_tips,*au_tips,*dn_tips,*rc_tips, *tk_tips;) N
(int) k
( context_id;) p n
() N
(/* audio_state: can be 1 or 2 corresponding to audio states \(see) c n
(   comment at top of file. */) N
(int) k
( audio_state = 0;) p n
() N
(/* when invoked \(via signal delete_event\), terminates the application.) c n
( */) N
(void) k
( close_application\( GtkWidget *widget, gpointer *data \) {) p n
(  free_mem\(\);) N
(  ) S
(if) K
(\(kill\(audio_pid,SIGINT\) == 0\) printf\(") p
(Killed Audio process\\n) str
("\);) p n
(  gtk_main_quit\(\);) N
(}) N
() N
(void) k
( ctrl_c_handler\() p
(int) k
( sig\)) p n
({) N
(  close_application\() S
(NULL) K
(,) p
(NULL) K
(\);) p n
(}) N
(gui.c) (Page 1/9) (May 15, 98 9:07) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/db_download.c, linux/gui.c) (21/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2-3) 22
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* is invoked when the button is clicked.  It just prints a message.) c n
( */) N
(void) k
( button_clicked\( GtkWidget *widget, gpointer *data \) {) p n
(  ) S
(int) k
( rval;) p n
(  ) S
(if) K
(\(\(audio_state == 2\) || \(audio_state == 1\)\) no_clicks = FALSE;) p n
(  printf\( ") S
(button clicked\\n) str
(" \);) p n
(  ) S
(/* listen button */) c n
(  ) p
(if) K
(\(widget ==ls_button\){) p n
(    gtk_statusbar_pop\(status_bar,context_id\);) N
(    gtk_statusbar_push\(status_bar,context_id,") S
(Listen mode) str
("\);) p n
(    ) N
(    ) S
(/* send signal to audio process */) c n
(    ) p
(if) K
(\(audio_state == 1\) {) p n
(      kill\(audio_pid,SIGUSR1\);) N
(      audio_state = 0;) N
(      sleep \(2\);) N
(      ) S
(while) K
(\(serialinit\(\)\);) p n
(      serialtransmit\(10\);) N
(      serialclose \(\);) N
(      kill \(audio_pid, SIGUSR2\);) N
(      audio_state = 2;) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
( \(audio_state == 0\) {) p n
(      changestate\(10\);) N
(      serialclose\(\);) N
(      kill\(audio_pid,SIGUSR2\);) N
(      audio_state = 2;) N
(    }) N
(    no_clicks = TRUE;) N
(    printf\(") S
(Signalled audio process SIGUSR2\\n) str
("\);) p n
(    ) S
(return) K
(;) p n
(  }) N
(  ) N
(  ) S
(/* Talk button */) c n
(  ) p
(if) K
(\(widget == tk_button\){) p n
(    gtk_statusbar_pop\(status_bar,context_id\);) N
(    gtk_statusbar_push\(status_bar,context_id,") S
(Talk mode) str
("\);) p n
(    ) N
(    ) S
(/* send signal to audio process */) c n
(    ) p
(if) K
(\(audio_state == 2\) {) p n
(      kill\(audio_pid,SIGUSR2\);) N
(      audio_state = 0;) N
(      sleep \(2\);) N
(      ) S
(while) K
(\(serialinit\(\)\);) p n
(      serialtransmit\(4\);) N
(      serialclose \(\);) N
(      kill \(audio_pid, SIGUSR1\);) N
(      audio_state = 1;) N
(    }) N
(    ) S
(else) K
( ) p
(if) K
( \(audio_state == 0\)) p n
(      {) N
() S 8 T (changestate\(4\);) N
() S 8 T (serialclose\(\);) N
() S 8 T (kill\(audio_pid,SIGUSR1\);) N
() S 8 T (audio_state = 1;) N
(      }) N
(    no_clicks = TRUE;) N
(    printf\(") S
(Signalled audio process SIGUSR1\\n) str
("\);) p n
(    ) S
(return) K
(;) p n
(  }) N
(  ) N
(gui.c) (Page 2/9) (May 15, 98 9:07) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p n
(  ) S
(/* config button */) c n
(  ) p
(if) K
(\(widget == cf_button\){) p n
(      ) S
(if) K
(\(fork\(\) == 0\) rval = execl\(") p
(/home/sysd7/source/X/config) str
(",) p n
() S 8 T () S 16 T () S 24 T () S 32 T (   ") S
(/home/sysd7/source/X/config) str
(",) p
(NULL) K
(\);) p n
(      ) S
(return) K
(;) p n
(  }) N
(  ) N
(  ) S
(/* open door */) c n
(  ) p
(if) K
(\(widget == button1\) {) p n
(    ) S
(if) K
(\(audio_state == 1\){) p n
(      kill\(audio_pid,SIGUSR1\);) N
(      audio_state = 0;) N
(      sleep \(2\);) N
(      ) S
(while) K
(\(serialinit\(\)\);) p n
(      serialtransmit\(8\);) N
(      registerhandler\(CONTROL,handle_control\);) N
(      initVideo \(\);) N
(      enablepackets \(\);) N
(    } ) S
(else) K
( ) p
(if) K
(\(audio_state == 2\){) p n
(      kill\(audio_pid,SIGUSR2\);) N
(      audio_state = 0;) N
(      sleep \(2\);) N
(      ) S
(while) K
(\(serialinit\(\)\);) p n
(      serialtransmit\(8\);) N
(      registerhandler\(CONTROL,handle_control\);) N
(      initVideo \(\);) N
(      enablepackets \(\);) N
(    } ) S
(else) K
( changestate\(8\);) p n
(    ) N
(    hide_buttons\(\);) N
(    ) S
(return) K
(;) p n
(  }) N
() N
(  ) S
(/* refuse entry */) c n
(  ) p
(if) K
(\(widget == button2\) {) p n
(    ) S
(if) K
(\(audio_state == 1\){) p n
(      kill\(audio_pid,SIGUSR1\);) N
(      audio_state = 0;) N
(      sleep \(2\);) N
(      ) S
(while) K
(\(serialinit\(\)\);) p n
(      serialtransmit\(7\);) N
(      registerhandler\(CONTROL,handle_control\);) N
(      initVideo \(\);) N
(      enablepackets \(\);) N
(    } ) S
(else) K
( ) p
(if) K
(\(audio_state == 2\){) p n
(      kill\(audio_pid,SIGUSR2\);) N
(      audio_state = 0;) N
(      sleep \(2\);) N
(      ) S
(while) K
(\(serialinit\(\)\);) p n
(      serialtransmit\(7\);) N
(      registerhandler\(CONTROL,handle_control\);) N
(      initVideo \(\);) N
(      enablepackets \(\);) N
(    } ) S
(else) K
( changestate\(7\);) p n
(    ) N
(    hide_buttons\(\);) N
(    ) S
(return) K
(;) p n
(  }) N
(  ) S
(/* recapture */) c n
(  ) p
(if) K
(\(widget == rc_button\) {) p n
(    gtk_statusbar_pop\(status_bar,context_id\);) N
(gui.c) (Page 3/9) (May 15, 98 9:07) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/gui.c) (22/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (4-5) 23
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    gtk_statusbar_push\(status_bar,context_id,") p
(Video mode) str
("\);) p n
(    ) S
(if) K
( \(audio_state\)) p n
(      {) N
() S 8 T () S
(switch) K
( \(audio_state\)) p n
() S 8 T (  {) N
() S 8 T (  ) S
(case ) K
(1) l
(:) p n
() S 8 T (    kill \(audio_pid, SIGUSR1\);) N
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  ) S
(case ) K
(2) l
(:) p n
() S 8 T (    kill \(audio_pid, SIGUSR2\);) N
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  }) N
() S 8 T (audio_state = 0;) N
() S 8 T (sleep \(5\);) N
() S 8 T () S
(while) K
( \(serialinit \(\)\);) p n
() S 8 T (serialtransmit \(3\);) N
() S 8 T (registerhandler \(CONTROL, handle_control\);) N
() S 8 T (initVideo \(\);) N
() S 8 T (enablepackets \(\);) N
(      }) N
(    ) S
(else) K n
(      {) p n
() S 8 T (changestate\(2\);) N
(      }) N
(    ) S
(return) K
(;) p n
(  }) N
(  ) S
(/* audio control */) c n
(  ) p
(if) K
(\(widget == au_button\){) p n
(    ) S
(if) K
(\(fork\(\) == 0\) rval = execl\(") p
(/usr/X386/bin/xmixer) str
(",) p n
() S 8 T () S 16 T () S 24 T () S 32 T ( ") S
(/usr/X386/bin/xmixer) str
(",) p
(NULL) K
(\);) p n
(  }) N
(}  ) N
() N
(void) k
( get_new_image\( GtkWidget *widget, gpointer *data\) ) p n
({) N
(  GtkStyle *style;) N
(  GdkBitmap *mask;) N
() N
(  ) S
(/* get image and resize */) c n
(  double_xpm\() p
(NULL) K
(\);) p n
() N
(  ) S
(/* free last pixmap */) c n
(  gdk_pixmap_unref\(pixmap\);) p n
() N
(  ) S
(/* create pixmap */) c n
(  style = gtk_widget_get_style\( window \);) p n
(  pixmap = gdk_pixmap_create_from_xpm_d\( window->window,  &mask,) N
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T ( &style->bg[GTK_STATE_NORMAL],) N
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T ( \() S
(char) k
( **\)xpm\);) p n
(  gtk_pixmap_set\( \(GtkPixmap *\)pixmapwid,pixmap,mask\);) N
(}) N
() N
(int) k
( gui_main\( ) p
(int) k
( argc, ) p
(char) k
( *argv[] \)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(/* start serial */) c n
(  serialinit\(\);) p n
() N
(  ) S
(/* request state change */) c n
(  serialtransmit \(1\);) p n
(#ifdef) K
( DEBUG) p n
(  printf \(") S
(Waiting for ping\\n) str
("\);) p n
(gui.c) (Page 4/9) (May 15, 98 9:07) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#endif) K n
(  ) p
(do) K n
(    {) p n
(      ) S
(if) K
( \(serialreceive \(\) != 2\)) p n
() S 8 T () S
(continue) K
(;) p n
(      ) S
(for) K
( \(i = 0; i < 4; i++\)) p n
() S 8 T () S
(if) K
( \(serialreceive \(\) != 0\)) p n
() S 8 T (  ) S
(break) K
(;) p n
(      ) S
(if) K
( \(i == 4\)) p n
() S 8 T () S
(break) K
(;) p n
(    }) N
(  ) S
(while) K
( \(1\);) p n
() N
(  serialtransmit \(2\);) N
() N
(  enablepackets \(\);) N
() N
(  initVideo\(\);) N
(  init_gui\(argc,argv\);) N
(  ) S
(return) K
( 1;) p n
(}) N
() N
(void) k
( init_gui\() p
(int) k
( argc, ) p
(char) k
( *argv[]\)) p n
({) N
(  ) S
(/* create the main window, and attach delete_event signal to terminating) c n
(     the application */) N
(  gtk_init\( &argc, &argv \);) p n
() N
(  ) S
(/* allocate mem for xpm */) c n
(  init_xpm\(\);) p n
(  ) N
(  ) S
(/* create window */) c n
(  window = gtk_window_new\( GTK_WINDOW_TOPLEVEL \);) p n
() N
(  gtk_window_set_title \(GTK_WINDOW \(window\), ") S
(Door Entry System) str
("\);) p n
() N
(  gtk_signal_connect\( GTK_OBJECT \(window\), ") S
(delete_event) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC \(close_application\), ) S
(NULL) K
( \);) p n
(  gtk_container_border_width\( GTK_CONTAINER \(window\), 10 \);) N
() N
(  ) S
(/* register the handler */) c n
(  registerhandler\(CONTROL,handle_control\);) p n
(  ) N
(  ) S
(/* create new boxes */) c n
(  master_box = gtk_vbox_new\(FALSE,1\);) p n
(  box = gtk_hbox_new \(FALSE, 1\);) N
(  button_box = gtk_hbox_new\(TRUE,1\);) N
(  lbox = gtk_vbox_new\(FALSE,1\);) N
(  rbox = gtk_vbox_new\(TRUE,1\);) N
() N
(  ) S
(/* now for the pixmap */) c n
() p n
(  style = gtk_widget_get_style\( window \);) N
(  printf\(") S
(Resizing...) str
("\);) p n
(  double_xpm\() S
(NULL) K
(\);) p n
(  printf\(") S
(done\\n) str
("\);) p n
(#ifdef) K
( DEBUG) p n
(  output_xpm\(\);) N
(#endif) K n
(  pixmap = gdk_pixmap_create_from_xpm_d\( window->window,  &mask,) p n
() S 8 T () S 16 T () S 24 T () S 32 T (       &style->bg[GTK_STATE_NORMAL],) N
() S 8 T () S 16 T () S 24 T () S 32 T (       \() S
(char) k
( **\)xpm\);) p n
(gui.c) (Page 5/9) (May 15, 98 9:07) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/gui.c) (23/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (6-7) 24
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(  ) S
(/* a pixmap widget to contain the pixmap */) c n
(  pixmapwid = gtk_pixmap_new\( pixmap, mask \);) p n
(  gtk_box_pack_start \(GTK_BOX \(lbox\), pixmapwid, TRUE, TRUE, TRUE\);) N
() N
(  ) S
(/* define the buttons and pack into boxes */) c n
(  ) p
(/*NB: show functions commented so buttons only appear later */) c n
() p n
(  cf_tips = gtk_tooltips_new\(\);) N
(  rc_tips = gtk_tooltips_new\(\);) N
(  dn_tips = gtk_tooltips_new\(\);) N
(  au_tips = gtk_tooltips_new\(\);) N
(  button1 = gtk_button_new_with_label\(") S
(Unlock) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(button1\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked\), button1 \);) N
(  gtk_box_pack_start \(GTK_BOX \(button_box\), button1, TRUE, TRUE, TRUE\);) N
(  ) S
(/*gtk_widget_show\( button1 \);*/) c n
() p n
(  button2 = gtk_button_new_with_label\(") S
(Refuse) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(button2\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked\), button2 \);) N
(  gtk_box_pack_start \(GTK_BOX \(button_box\), button2, TRUE, TRUE, TRUE\);) N
(  ) S
(/*gtk_widget_show\( button2 \);*/) c n
() p n
() N
(  tk_button = gtk_button_new_with_label\(") S
(Talk) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(tk_button\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked\), tk_button \);) N
(  gtk_box_pack_start \(GTK_BOX \(rbox\), tk_button, TRUE, TRUE, TRUE\);) N
(  gtk_tooltips_set_tip\(GTK_OBJECT\(dn_tips\),GTK_OBJECT\(tk_button\),) N
() S 8 T () S 16 T () S 24 T (") S
(Talk to visitor) str
(",) p
(NULL) K
(\);) p n
(  ) S
(/*gtk_widget_show\( tk_button \);*/) c n
() p n
(    ls_button = gtk_button_new_with_label\(") S
(Listen) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(ls_button\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked\), ls_button \);) N
(  gtk_box_pack_start \(GTK_BOX \(rbox\), ls_button, TRUE, TRUE, TRUE\);) N
(  gtk_tooltips_set_tip\(GTK_OBJECT\(dn_tips\),GTK_OBJECT\(ls_button\),) N
() S 8 T () S 16 T () S 24 T (") S
(Let the visitor talk to you) str
(",) p
(NULL) K
(\);) p n
(  ) S
(/*gtk_widget_show\( ls_button \);*/) c n
() p n
() N
(  rc_button = gtk_button_new_with_label\(") S
(Video) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(rc_button\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked \), rc_button \);) N
(  gtk_box_pack_start \(GTK_BOX \(rbox\), rc_button, FALSE, TRUE, TRUE\);) N
(  gtk_tooltips_set_tip\(GTK_OBJECT\(rc_tips\),GTK_OBJECT\(rc_button\),) N
() S 8 T () S 16 T () S 24 T (") S
(Grab frames from camera) str
(",) p
(NULL) K
(\);) p n
(  gtk_widget_show\( rc_button \);) N
() N
(  ) S
(/* create a separator) c n
(   */) N
(  separator=gtk_hseparator_new\(\);) p n
(  gtk_box_pack_start \(GTK_BOX \(rbox\), separator, TRUE, TRUE, TRUE\);) N
(  ) S
(/*gtk_widget_show\(separator\);*/) c n
(  ) p n
(  au_button = gtk_button_new_with_label\(") S
(Audio Control) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(au_button\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked\), au_button \);) N
(  gtk_box_pack_start \(GTK_BOX \(rbox\), au_button, FALSE, TRUE, TRUE\);) N
(  gtk_tooltips_set_tip\(GTK_OBJECT\(au_tips\),GTK_OBJECT\(au_button\),) N
() S 8 T () S 16 T () S 24 T (") S
(Change mic/speaker volumes) str
(",) p
(NULL) K
(\);) p n
(gui.c) (Page 6/9) (May 15, 98 9:07) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  gtk_widget_show\( au_button \);) p n
() N
(  cf_button = gtk_button_new_with_label\(") S
(Configure) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(cf_button\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC\(button_clicked\), cf_button \);) N
(  gtk_tooltips_set_tip\(GTK_OBJECT\(cf_tips\),GTK_OBJECT\(cf_button\),) N
() S 8 T () S 16 T () S 24 T (") S
(Add/delete users and change options) str
(",) p
(NULL) K
(\);) p n
(  gtk_box_pack_start \(GTK_BOX \(rbox\), cf_button, FALSE, TRUE, TRUE\);) N
(  gtk_widget_show\( cf_button \);) N
() N
(  cl_button = gtk_button_new_with_label\(") S
(Close) str
("\);) p n
(  gtk_signal_connect\( GTK_OBJECT\(cl_button\), ") S
(clicked) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC \(close_application\), ) S
(NULL) K
( \);) p n
(  gtk_box_pack_start \(GTK_BOX \(rbox\), cl_button, FALSE, TRUE, 0\);) N
(  gtk_widget_show\( cl_button \);) N
() N
(  gtk_widget_show\( button_box \);) N
(  gtk_widget_show\( rbox \);) N
() N
(  ) S
(/* pack button box into main box */) c n
(  gtk_box_pack_start \(GTK_BOX \(lbox\), button_box, TRUE, TRUE, TRUE\);) p n
(  gtk_widget_show\( pixmapwid \);  ) N
(  gtk_widget_show\( lbox \);) N
(  printf\(") S
(showed pixmap and lbox\\n) str
("\);) p n
() N
(  ) S
(/* pack left and right boxes into main box */) c n
() p n
(  gtk_box_pack_start \(GTK_BOX \(box\), lbox, TRUE, TRUE, TRUE\);) N
(  gtk_box_pack_start \(GTK_BOX \(box\), rbox, TRUE, TRUE, TRUE\);) N
() N
(  gtk_widget_show\(box\);) N
() N
(  gtk_box_pack_start \(GTK_BOX \(master_box\), box, TRUE, TRUE, TRUE\);) N
(  ) N
(  ) S
(/* a status bar */) c n
(  status_bar = gtk_statusbar_new\(\);      ) p n
(  gtk_box_pack_start \(GTK_BOX \(master_box\), status_bar, TRUE, TRUE, 0\);) N
(  gtk_widget_show \(status_bar\);) N
(  context_id = gtk_statusbar_get_context_id\( GTK_STATUSBAR\(status_bar\), ") S
(Normal) str
(") p n
(\);) N
(  gtk_statusbar_push\(status_bar,context_id,") S
(Video mode) str
("\);) p n
() N
(  gtk_container_add\( GTK_CONTAINER\(window\), master_box \);) N
(  ) N
(  ) S
(/* show the window */) c n
(  gtk_widget_show\( master_box\);) p n
(  gtk_widget_show\( window \);) N
() N
(  gtk_main \(\);) N
(}) N
() N
(/* called by video module when a new video frame arrives */) c n
(void) k
( display_image\() p
(char) k
( *image\)) p n
({) N
(  GtkStyle *style;) N
(  GdkBitmap *mask;) N
() N
(  double_xpm\(image\);) N
() N
(  gdk_pixmap_unref\(pixmap\);) N
() N
(  style = gtk_widget_get_style\( window \);) N
(gui.c) (Page 7/9) (May 15, 98 9:07) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/gui.c) (24/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (8-9) 25
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  pixmap = gdk_pixmap_create_from_xpm_d\( window->window,  &mask,) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T ( &style->bg[GTK_STATE_NORMAL],) N
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T ( \() S
(char) k
( **\)xpm\);) p n
(  gtk_pixmap_set\( \(GtkPixmap *\)pixmapwid,pixmap,mask\);) N
(  ) S
(/* turn on clicks */) c n
(  no_clicks = FALSE;) p n
(}) N
() N
(/* handle control packets from board */) c n
(void) k
( handle_control\(packet *p\)) p n
({) N
(  GtkWidget *label,*picwid,*vbox;) N
(  GdkPixmap *pxmp;) N
(  GtkStyle *style;) N
(  GdkBitmap *mask;) N
(  ) S
(int) k
( x = TRUE;) p n
() N
(  ) S
(/* Code for a Buzzer press */) c n
(  ) p n
(  ) S
(/*  if\(*\(p->data\) == BUZZER_PRESSED\){*/) c n
(  ) p
(if) K
(\(x\){) p n
(    ) S
(/* pop the gui up if not already up. Make a sound and display) c n
(       requester */) N
(    bellwin=gtk_window_new\(GTK_WINDOW_DIALOG\);) p n
(    gtk_window_set_title\(GTK_WINDOW\(bellwin\), ") S
(Doorbell) str
("\);) p n
(    gtk_signal_connect\( GTK_OBJECT \(bellwin\), ") S
(delete_event) str
(",) p n
() S 8 T () S 16 T (      GTK_SIGNAL_FUNC \(gtk_object_destroy\), bellwin \);) N
() N
() N
(    vbox = gtk_vbox_new\(FALSE,1\);) N
(    gtk_container_add\(GTK_CONTAINER\(bellwin\),vbox\);) N
(    gtk_widget_show\(vbox\);) N
(    ) N
(    style = gtk_widget_get_style\( bellwin \);) N
(    pxmp = gdk_pixmap_create_from_xpm\( bellwin->window,  &mask,) N
() S 8 T () S 16 T () S 24 T () S 32 T (       &style->bg[GTK_STATE_NORMAL],) N
() S 8 T () S 16 T () S 24 T () S 32 T (       ") S
(/home/sysd7/bell.xpm) str
("\);) p n
() N
(    picwid = gtk_pixmap_new\( pxmp, mask \);) N
(    gtk_box_pack_start\(GTK_BOX\(vbox\),picwid,TRUE,TRUE,TRUE\);) N
(    gtk_widget_show\(picwid\);) N
(    ) N
(    label = gtk_label_new\(") S
(Someone is at the door!) str
("\);) p n
(    gtk_box_pack_start\(GTK_BOX\(vbox\),label,TRUE,TRUE,TRUE\);) N
(    gtk_widget_show\(label\);) N
(    ) N
(    gtk_widget_show\(bellwin\);    ) N
() N
(    ) S
(/* play sample */) c n
(    ) p
(if) K
(\(fork\(\)==0\) execl\(") p
(/home/sysd7/sndscript) str
(",") p
(/home/sysd7/sndscript) str
(",) p
(NULL) K
(\);) p n
(    show_buttons\(\);) N
(  }) N
(}) N
() N
(void) k
( hide_buttons\(\)) p n
({) N
(    gtk_widget_hide\( button1 \);) N
(    gtk_widget_hide\( button2 \);) N
(    ) N
(    gtk_widget_hide\( tk_button\);) N
(    gtk_widget_hide\( ls_button\);) N
(    gtk_widget_hide\(separator\);) N
(gui.c) (Page 8/9) (May 15, 98 9:07) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    gtk_widget_destroy\(bellwin\);) p n
(    ) S
(/* update statusbar */) c n
(    gtk_statusbar_push\(status_bar,context_id,") p
(Video mode) str
("\);) p n
(}) N
(  ) N
(void) k
( show_buttons\(\)) p n
({) N
(    gtk_widget_show\( button1 \);) N
(    gtk_widget_show\( button2 \);) N
(    gtk_widget_show\( tk_button \);) N
(    gtk_widget_show\( ls_button \);) N
(    gtk_widget_show\(separator\);) N
(}) N
(gui.c) (Page 9/9) (May 15, 98 9:07) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/gui.c) (25/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 26
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Functions to load the database from disk */) c
( ) p n
() N
(#include) K
( <stdio.h>) p n
(#include) K
( ") p
(../dbm_defs.h) str
(") p n
() N
(/* database pointer */) c n
(db_item *database;) p n
() N
(/* function prototypes */) c n
(db_item *make_llist\() p
(FILE) k
( *file\);) p n
(void) k
( free_database\(\);) p n
(db_item *get_db_index\() S
(char) k
( *name\);) p n
() N
(int) k
( users;) p n
() N
(/* returns number of items read. Need to load into single buffer,) c n
(ready for transmission. ie. all user x's details next to each) N
(other. structure? */) N
() p n
(int) k
( load_database\(\)) p n
({) N
(  ) S
(FILE) k
( *file;) p n
(  ) S
(char) k
( get_uid[UID_SIZE+1];) p n
(  ) S
(char) k
( get_pin[PIN_SIZE+1];) p n
(  ) S
(char) k
( get_sname[NAME_SIZE];) p n
(  ) S
(char) k
( get_fname[NAME_SIZE];) p n
() N
(  printf\(") S
(Database:\\n) str
("\);) p n
() N
(  ) S
(/* try to open 'users' file */) c n
(  file = fopen\(DB_FILENAME,") p
(r) str
("\);) p n
(  ) S
(if) K
(\(file == ) p
(NULL) K
(\) {) p n
(    printf\(") S
(File problem!\\n) str
("\);) p n
(    ) S
(return) K
( FALSE;) p n
(  }) N
() N
(  database = make_llist\(file\);) N
() N
(  printf\(") S
(Database loaded - %i users\\n) str
(",users\);) p n
(  fclose\(file\);) N
(  ) S
(return) K
( users;) p n
(}) N
() N
(/* Recursive function to build up the linked list of database items */) c n
() p n
(db_item *make_llist\() S
(FILE) k
( *file\)) p n
({) N
(  db_item *head;) N
(  ) S
(char) k
( get_uid[UID_SIZE+1];) p n
(  ) S
(char) k
( get_pin[PIN_SIZE+1];) p n
(  ) S
(char) k
( get_sname[NAME_SIZE];) p n
(  ) S
(char) k
( get_fname[NAME_SIZE];) p n
(  ) S
(char) k
( get_dept[NAME_SIZE];) p n
(  ) S
(char) k
( get_photo[NAME_SIZE];) p n
(  ) S
(char) k
( lock;) p n
() N
(  ) S
(/* file format is:) c n
(     UID PIN FNAME SNAME XPM_FILENAME|% DEPT L|N) N
(  */) N
(                         ) p n
(  ) N
() N
(load_db.c) (Page 1/2) (May 15, 98 8:56) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(if) K
(\(fscanf\(file,") p
(%s %s %s %s %s %s %c\\n) str
(",) p n
() S 8 T ( &get_uid,&get_pin,&get_fname,&get_sname,&get_photo,&get_dept,&lock\) ) N
() S 8 T ( == EOF \) ) S
(return) K
( ) p
(NULL) K
(;) p n
(  ) S
(else) K
( {) p n
(    head = \(db_item *\)malloc\() S
(sizeof) K
(\(db_item\)\);) p n
() N
(    printf\(") S
(Allocated memory for db_item\\n) str
("\);) p n
(    strcpy\(head->uid,get_uid\);) N
(    strcpy\(head->pin,get_pin\);) N
(    strcpy\(head->fname,get_fname\);) N
(    strcpy\(head->sname,get_sname\);) N
(    strcpy\(head->dept,get_dept\);) N
(    strcpy\(head->photo,get_photo\);) N
(    head->lock = lock;) N
(    printf\(") S
(Loading %s %s %s\\n) str
(",get_fname,get_sname,get_uid\);) p n
(    head->next = make_llist\(file\);) N
(    users++;) N
(    ) S
(return) K
( head;) p n
(  }) N
(}) N
() N
(void) k
( free_database\(\)) p n
({) N
(  db_item *curr=database,*next;) N
() N
(  ) S
(while) K
(\(curr\){) p n
(    printf\(") S
(Freeing %s\\n) str
(",curr->sname\);) p n
(    next = curr->next;) N
(    free\(curr\);) N
(    curr = next;) N
() N
(  }) N
(}) N
() N
(/* Returns a pointer to a user's record structure when given a text) c n
( * string of the users name \(fname+sname\).) N
( */) N
(db_item *get_db_item\() p
(char) k
( *name\)) p n
({) N
(  ) S
(char) k
( fname[NAME_SIZE];) p n
(  ) S
(char) k
( sname[NAME_SIZE];) p n
(  db_item *curr=database;) N
(  printf\(") S
(get_db_item: string = %s\\n) str
(",name\);) p n
(  ) N
(  printf\(") S
(%s\\n) str
(",name\);  ) p n
(  ) S
(/* first, separate name string */) c n
(  sscanf\(name,") p
(%s %s) str
(",fname,sname\);) p n
() N
(  ) S
(while) K
(\(curr\){) p n
(    ) S
(if) K
(\(strcmp\(curr->sname,sname\)==0 &&) p n
(       strcmp\(curr->fname,fname\)==0\) ) S
(return) K
( curr;) p n
(    printf\(") S
(get_db_item: searched %s\\n) str
(",curr->sname\);) p n
(    curr = curr->next;) N
(  }) N
(  ) S
(return) K
( ) p
(NULL) K
(;) p n
(}) N
(load_db.c) (Page 2/2) (May 15, 98 8:56) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/load_db.c) (26/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 27
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Linux Main */) c n
() p n
(#include) K
( <signal.h>) p n
() N
(int) k
( audio_pid;) p n
(extern) K
( ) p
(void) k
( close_application\() p
(int) k
(\);) p n
() N
(/* forks off a child process for audio and saves its uid in a global */) c n
() p n
(int) k
( main\( ) p
(int) k
( argc, ) p
(char) k
( *argv[] \)) p n
({) N
(  audio_pid = fork\(\);) N
(  ) S
(if) K
(\(audio_pid == 0\) audio_main\(\);) p n
(  ) S
(else) K
( {) p n
(    printf\(") S
(forked Audio with pid %i\\n) str
(",audio_pid\);) p n
(    ) S
(/* set up ctrl-c handler */) c n
(    signal\(SIGINT,close_application\);) p n
(    gui_main\(argc,argv\);) N
(  }) N
(}) N
(lx_main.c) (Page 1/1) (May 15, 98 9:09) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Linux interrupt-driven serial code) c n
(   Stephen Kitt) N
(*/) N
() p n
(#include) K
( <termios.h>) p n
(#include) K
( <unistd.h>) p n
(#include) K
( <sys/types.h>) p n
(#include) K
( <sys/stat.h>) p n
(#include) K
( <fcntl.h>) p n
(#include) K
( <stdio.h>) p n
(#include) K
( <errno.h>) p n
(#include) K
( <signal.h>) p n
(#include) K
( <sys/time.h>) p n
() N
(#include) K
( <serial.h>) p n
() N
(/* Serial file descriptor */) c n
(int) k
( serialfd;) p n
() N
(/* Packet handling flag */) c n
(int) k
( packets;) p n
() N
(/* Packet handlers */) c n
(packethandler handlers [256];) p n
() N
(/* Serial input buffer information - size, buffer, length, current) c n
(   read and write indices, lock */) N
(#define) K
( SERIALINSIZE 32768) p n
(unsigned) k
( ) p
(char) k
( inbuffer [SERIALINSIZE];) p n
(volatile) K
( ) p
(unsigned) k
( ) p
(int) k
( inbl, inbr, inbw;) p n
(volatile) K
( inblock;) p n
() N
(/* Temporary packet storage */) c n
(packet pkt;) p n
(int) k
( pktlen;) p n
(unsigned) k
( ) p
(char) k
( pktbuf [SERIALINSIZE];) p n
() N
(/* Ping indicator */) c n
(int) k
( __ping;) p n
() N
(/* Default handler - handles pings */) c n
(void) k
( defaulthandler \(packet * in\)) p n
({) N
(#ifdef) K
( DEBUG) p n
(  printf \(") S
(Default handler called, data type %d\\n) str
(", \() p
(int) k
(\)) p n
() S 8 T (  in->datatype\);) N
(#endif) K n
(  ) p
(/* If we receive a ping, acknowledge it immediately */) c n
(  ) p
(if) K
( \(in->datatype == 1\)) p n
(    {) N
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Received ping, acknowledging) str
("\);) p n
(#endif) K n
(      serialtransmit \(2\);) p n
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Ping acknowledged) str
("\);) p n
(#endif) K n
(    }) p n
(  ) S
(/* If we receive a ping acknowledgement, store that fact */) c n
(  ) p
(if) K
( \(in->datatype == 2\)) p n
(    {) N
(#ifdef) K
( DEBUG) p n
(serial.c) (Page 1/7) (May 14, 98 23:31) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/lx_main.c, linux/serial.c) (27/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2-3) 28
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(      puts \(") p
(Serial: received ping acknowledgement) str
("\);) p n
(#endif) K n
(      __ping = 1;) p n
(    }) N
(}) N
() N
(/* Serial event handler */) c n
(void) k
( serialevent \() p
(void) k
(\)) p n
({) N
(  fd_set rfds;) N
(  ) S
(struct) k
( timeval tv;) p n
(  ) S
(int) k
( i;) p n
() N
(  ) S
(/* If the input buffer is currently locked, indicate we need it) c n
(     eventually, otherwise lock it */) N
(  ) p
(if) K
( \(inblock == 1\)) p n
(    {) N
(      inblock = 2;) N
(      ) S
(return) K
(;) p n
(    }) N
(  ) S
(else) K n
(    inblock == 1;) p n
(  ) N
(  ) S
(/* Use select to determine if we can read */) c n
(  FD_ZERO \(&rfds\);) p n
(  FD_SET \(serialfd, &rfds\);) N
(  tv.tv_sec = 0;) N
(  tv.tv_usec = 0;) N
(  select \(serialfd + 1, &rfds, ) S
(NULL) K
(, ) p
(NULL) K
(, &tv\);) p n
() N
(  ) S
(/* If we can read... */) c n
(  ) p
(if) K
( \(FD_ISSET \(serialfd, &rfds\)\)) p n
(    {) N
(      ) S
(/* Read as many bytes as we can */) c n
(      i = read \(serialfd, &\(inbuffer [inbw]\), SERIALINSIZE - inbw\);) p n
() N
(      ) S
(/* If this didn't fail, update the write pointer and length */) c n
(      ) p
(if) K
( \(i != -1\)) p n
() S 8 T ({) N
() S 8 T (  inbw = \(inbw + i\) % SERIALINSIZE;) N
() S 8 T (  inbl += i;) N
() S 8 T (}) N
() N
(      ) S
(/* If we're handling packets... */) c n
(      ) p
(if) K
( \(packets\)) p n
() S 8 T ({) N
() S 8 T (  ) S
(/* If we've got more than five characters, we've got a packet */) c n
() p 8 T (  ) S
(if) K
( \(inbl >= 5 && pktlen == -1\)) p n
() S 8 T (    {) N
(#ifdef) K
( DEBUG) p n
() S 8 T (      printf \(") S
(Serial: ) str
("\);) p n
() S 8 T (      ) S
(for) K
( \(i = inbr; i < inbr + 5; i++\)) p n
() S 8 T () S 16 T (printf \(") S
(%2.2X ) str
(", inbuffer [i % SERIALINSIZE]\);) p n
() S 8 T (      printf \(") S
(\\n\\r) str
("\);) p n
() S 8 T (      printf \(") S
(Serial: inbl = %d, inbr = %d, inbw = %d\\n) str
(",) p n
() S 8 T () S 16 T (      inbl, inbr, inbw\);) N
(#endif) K n
() p 8 T (      ) S
(/* Store the datatype */) c n
() p 8 T (      pkt.datatype = inbuffer [inbr];) N
(#ifdef) K
( DEBUG) p n
() S 8 T (      printf \(") S
(Serial: read datatype: %d\\n) str
(", \() p
(int) k
(\) pkt.datatype\);) p n
() S 8 T (      printf \(") S
(Serial: reading length: ) str
("\);) p n
(serial.c) (Page 2/7) (May 14, 98 23:31) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#endif) K n
() p 8 T (      ) S
(/* Clear the packet length, and read it in */) c n
() p 8 T (      pktlen = 0;) N
() S 8 T (      ) S
(for) K
( \(i = inbr + 1; i < inbr + 5; i++\)) p n
() S 8 T () S 16 T ({) N
(#ifdef) K
( DEBUG) p n
() S 8 T () S 16 T (  printf \(") S
(%2.2X ) str
(", inbuffer [i % SERIALINSIZE]\);) p n
(#endif) K n
() p 8 T () S 16 T (  pktlen = \(pktlen << 8\) + inbuffer [i % SERIALINSIZE];) N
() S 8 T () S 16 T (}) N
(#ifdef) K
( DEBUG) p n
() S 8 T (      printf \(") S
(= %d\\n) str
(", pktlen\);) p n
(#endif) K
() p 8 T (  ) N
() S 8 T (    }) N
() S 8 T (  ) S
(/* If we've got at least as many bytes as the packet length) c n
() S 8 T (     plus five, we've got a packet */) N
() p 8 T (  ) S
(if) K
( \(inbl >= pktlen + 5 && pktlen != -1\)) p n
() S 8 T (    {) N
() S 8 T (      ) S
(/* Update the read pointer and length */) c n
() p 8 T (      inbr = \(inbr + 5\) % SERIALINSIZE;) N
() S 8 T (      inbl -= 5;) N
(#ifdef) K
( DEBUG) p n
() S 8 T (      printf) N
(\(") S
(Serial: read data; inbl = %d, inbr = %d, inbw = %d, pktlen = %d\\n) str
(",) p n
( inbl, inbr, inbw, pktlen\);) N
(#endif) K n
() p 8 T (      ) S
(/* Copy the data into the temporary packet */) c n
() p 8 T (      ) S
(for) K
( \(i = 0; i < pktlen; i++\)) p n
() S 8 T () S 16 T ({) N
() S 8 T () S 16 T (  pktbuf [i] = inbuffer [\(inbr + i\) % SERIALINSIZE];) N
() S 8 T () S 16 T (}) N
() S 8 T (      ) N
() S 8 T (      ) S
(/* Update the read pointer and length */) c n
() p 8 T (      inbr = \(inbr + pktlen\) % SERIALINSIZE;) N
() S 8 T (      inbl -= pktlen;) N
() S 8 T (      ) N
() S 8 T (      ) S
(/* Store the packet information */) c n
() p 8 T (      pkt.data = pktbuf;) N
() S 8 T (      pkt.length = pktlen;) N
() S 8 T (      ) N
() S 8 T (      ) S
(/* Call the handler */) c n
() p 8 T (      ) S
(if) K
( \(handlers [pkt.datatype] != ) p
(NULL) K
(\)) p n
() S 8 T () S 16 T ({) N
(#ifdef) K
( DEBUG) p n
() S 8 T () S 16 T (  puts \(") S
(Serial: calling data handler) str
("\);) p n
(#endif) K n
() p 8 T () S 16 T (  handlers [pkt.datatype] \(&pkt\);) N
() S 8 T () S 16 T (}) N
() S 8 T (      ) N
() S 8 T (      ) S
(/* Clear out the packet length */) c n
() p 8 T (      pktlen = -1;) N
() S 8 T (      ) N
() S 8 T (      ) S
(/* If there's still something left, we've either made a) c n
() S 8 T () S 16 T ( mistake or we've got two packets close together... */) N
() p 8 T (      ) S
(if) K
( \(inbl > 0\)) p n
() S 8 T () S 16 T (puts \(") S
(Serial: possible problem) str
("\);) p n
(#ifdef) K
( DEBUG) p n
() S 8 T (      printf \(") S
(Serial: inbl = %d, inbr = %d, pktlen = %d\\n) str
(",) p n
() S 8 T () S 16 T (      inbl, inbr, pktlen\);) N
(#endif) K n
() p 8 T (    }) N
() S 8 T (}) N
(serial.c) (Page 3/7) (May 14, 98 23:31) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/serial.c) (28/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (4-5) 29
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    }) p n
() N
(  ) S
(/* Release the lock */) c n
(  inblock = 0;) p n
(}) N
() N
(/* IOSIG handler */) c n
(void) k
( iosighandler \() p
(int) k
( arg\)) p n
({) N
(  serialevent \(\);) N
(}) N
() N
(/* Serial initialisation function */) c n
(int) k
( serialinit \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(struct) k
( termios termios;) p n
(  ) S
(struct) k
( sigaction sa;) p n
() N
(  ) S
(/* Clear the ping, pointers, lock and packet length */) c n
(  __ping = 0;) p n
(  inbl = inbr = inbw = 0;) N
(  inblock = 0;) N
(  pktlen = -1;) N
() N
(  ) S
(/* Install our signal handler */) c n
(  sa.sa_handler = iosighandler;) p n
(  sa.sa_mask = 0;) N
(  sa.sa_flags = 0;) N
(  sa.sa_restorer = ) S
(NULL) K
(;) p n
(  sigaction \(SIGIO, &sa, ) S
(NULL) K
(\);) p n
() N
(  ) S
(/* Open the tty */) c n
(  serialfd = open \(") p
(/dev/ttyS1) str
(", O_RDWR | O_NOCTTY | O_NONBLOCK\);) p n
(  ) S
(if) K
( \(serialfd == -1\)) p n
(    ) S
(return) K
( -1;) p n
(  ) N
(  ) S
(/* Change the tty so we get SIGIO */) c n
(  fcntl \(serialfd, F_SETOWN, getpid \(\)\);) p n
(  fcntl \(serialfd, F_SETFL, FASYNC\);) N
() N
(  ) S
(/* Setup 38400bps, 8 bit characters, no modem stuff, ignore parity) c n
(   */) N
(  termios.c_cflag = B38400 | CS8 | CREAD | CLOCAL;) p n
(  termios.c_iflag = IGNPAR;) N
(  termios.c_oflag = 0;) N
(  termios.c_lflag = 0;) N
() N
(  ) S
(/* Totally non-blocking I/O */) c n
(  termios.c_cc[VTIME] = 0;) p n
(  termios.c_cc[VMIN] = 0;) N
() N
(  ) S
(/* Flush */) c n
(  tcflush \(serialfd, TCIFLUSH\);) p n
(  tcflush \(serialfd, TCOFLUSH\);) N
() N
(  ) S
(/* Store attributes */) c n
(  tcsetattr \(serialfd, TCSANOW, &termios\);) p n
() N
(  ) S
(/* Initialise the handlers */) c n
(  handlers [0] = defaulthandler;) p n
(  handlers [1] = defaulthandler;) N
(serial.c) (Page 4/7) (May 14, 98 23:31) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  handlers [2] = defaulthandler;) p n
(  ) S
(for) K
( \(i = 3; i < 256; i++\)) p n
(    handlers [i] = ) S
(NULL) K
(;) p n
() N
(  ) S
(/* Disable packets */) c n
(  packets = 0;) p n
() N
(  ) S
(/* Success */) c n
(  ) p
(return) K
( 0;) p n
(}) N
() N
(/* Close the serial */) c n
(int) k
( serialclose \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Wait for transactions to finish */) c n
(  ) p
(while) K
( \(inbl > 0\);) p n
() N
(  ) S
(/* Release tty */) c n
(  close \(serialfd\);) p n
() N
(  ) S
(/* Success */) c n
(  ) p
(return) K
( 0;) p n
(}) N
() N
(/* Send a data packet */) c n
(int) k
( senddata \(packet * pkt\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( c;) p n
() N
(#ifdef) K
( DEBUG) p n
(  printf \(") S
(Serial: sending a packet, type %d, length %d\\n) str
(",) p n
() S 8 T (  pkt->datatype, pkt->length\);) N
(#endif) K n
(  ) p
(/* Write the datatype */) c n
(  write \(serialfd, &\(pkt->datatype\), 1\);) p n
() N
(  ) S
(/* Write the length */) c n
(  ) p
(for) K
( \(i = 24; i >= 0; i -= 8\)) p n
(    {) N
(      c = \(pkt->length & \(0x000000FF << i\)\) >> i;) N
(      write \(serialfd, &c, 1\);) N
(    }) N
() N
(  ) S
(/* Write the data */) c n
(  ) p
(for) K
( \(i = 0; i < pkt->length; i++\)) p n
(    write \(serialfd, &\(pkt->data [i]\), 1\);) N
() N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: packet sent) str
("\);) p n
(#endif) K n
() p n
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Send a single character */) c n
(int) k
( serialtransmit \() p
(unsigned) k
( ) p
(char) k
( c\)) p n
({) N
(  write \(serialfd, &c, 1\);) N
() N
(  ) S
(return) K
( 0;) p n
(}) N
(serial.c) (Page 5/7) (May 14, 98 23:31) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/serial.c) (29/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (6-7) 30
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* Receive a single character */) c n
(int) k
( serialreceive \() p
(void) k
(\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(char) k
( r;) p n
(  ) N
(  ) S
(/* As long as we're not getting anything, sleep a while and try to) c n
(     force the issue - timeout is 5 seconds */) N
(  ) p
(while) K
( \(inbl == 0\)) p n
(    {) N
(      ) S
(if) K
( \(sleep \(5\) == 0\)) p n
() S 8 T () S
(return) K
( -1;) p n
(      serialevent \(\);) N
(    }) N
() N
(  ) S
(/* Lock the buffer */) c n
(  inblock = 1;) p n
() N
(  ) S
(/* Reduce the length, extract the character, and update the read) c n
(     pointer */) N
(  inbl--;) p n
(  r = inbuffer [inbr];) N
(  inbr = \(inbr + 1\) % SERIALINSIZE;) N
() N
(  ) S
(/* If serialevent requested a call, call it */) c n
(  ) p
(if) K
( \(inblock == 2\)) p n
(    serialevent \(\);) N
(  ) N
(  ) S
(return) K
( \() p
(int) k
(\) r;) p n
(}) N
() N
(/* Register a handler */) c n
(int) k
( registerhandler \() p
(unsigned) k
( ) p
(char) k
( datatype, packethandler handler\)) p n
({) N
(  handlers [datatype] = handler;) N
() N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Unregister a handler */) c n
(int) k
( unregisterhandler \() p
(unsigned) k
( ) p
(char) k
( datatype\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(if) K
( \(datatype > 2\)) p n
(    handlers [datatype] = ) S
(NULL) K
(;) p n
(  ) S
(else) K n
(    handlers [datatype] = defaulthandler;) p n
() N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Send a ping */) c n
(int) k
( ping \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( sr;) p n
() N
(  ) S
(/* Clear the ping indicator */) c n
(  __ping = 0;) p n
() N
(  ) S
(/* Send the ping */) c n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: pinging) str
("\);) p n
(serial.c) (Page 6/7) (May 14, 98 23:31) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#endif) K n
(  serialtransmit \(1\);) p n
() N
(  ) S
(/* Wait for the ping indicator to change */) c n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: waiting for acknowledgement) str
("\);) p n
(#endif) K n
(  ) p
(while) K
( \(!__ping\)) p n
(    ) S
(if) K
( \(sleep \(10\) == 0\)) p n
(      ) S
(return) K
( -1;) p n
() N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: received acknowledgement) str
("\);) p n
(#endif) K n
(  ) p
(return) K
( 1;) p n
(}) N
() N
(/* Send a change state message */) c n
(void) k
( changestate \() p
(unsigned) k
( ) p
(char) k
( state\)) p n
({) N
(#ifdef) K
( DEBUG) p n
(  printf \(") S
(Serial: changing state to %d\\n) str
(", \() p
(int) k
(\) state\);) p n
(#endif) K n
(  ) p
(/* Send a ping */) c n
(  ping \(\);) p n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: transmitting new state) str
("\);) p n
(#endif) K n
(  ) p
(/* Send the new state */) c n
(  serialtransmit \(state\);) p n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: sent new state) str
("\);) p n
(#endif) K n
(}) p n
() N
(/* Enable packets */) c n
(void) k
( enablepackets \() p
(void) k
(\)) p n
({) N
(  packets = 1;) N
(}) N
() N
(/* Disable packets */) c n
(void) k
( disablepackets \() p
(void) k
(\)) p n
({) N
(  packets = 0;) N
(}) N
(serial.c) (Page 7/7) (May 14, 98 23:31) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/serial.c) (30/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 31
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
(  Linux video reception and decompression code) N
(  $Id: video.c,v 1.11 1998/05/07 14:04:44 iic Exp iic $) N
(  $Log: video.c,v $) N
(  Revision 1.11  1998/05/07 14:04:44  iic) N
(  Added restartVideo - Untested) N
() N
(  Revision 1.10  1998/05/07 13:40:09  iic) N
(  Waaaaaaaaaaaaaaaahhhhhhhhhhhhhhoooooooooooooo!  IT WORKS!) N
() N
(  Revision 1.9  1998/05/07 13:01:16  iic) N
(  Works, but still has loads of debugging stuff \(incl CRC\)) N
() N
(  Revision 1.8  1998/05/06 15:20:25  iic) N
(  Added CRC checking to Video - not yet tested it though) N
() N
(  Revision 1.7  1998/05/06 14:58:47  skk) N
(  Initial changes to merge with serial.) N
() N
(  Revision 1.6  1998/05/04 12:16:31  iic) N
(  Now ready for testing, will output image to STDOUT as text) N
() N
(  Revision 1.5  1998/04/30 10:06:07  iic) N
(  Fixed ENUM bug.) N
() N
(  Revision 1.4  1998/04/29 13:41:38  iic) N
(  Used data.VIDEO definition in data.h) N
() N
(  Revision 1.3  1998/04/28 13:25:32  iic) N
(  Minor commenting changes.) N
() N
(*/) N
() p n
(#include) K
( <serial.h>) p n
(#include) K
( <linux.video.h>) p n
(#include) K
( <data.h>) p n
(#include) K
( <control.h>) p n
() N
(/*) c n
(  Some bit manipulation utilities) N
(*/) N
() p n
(int) k
( getbit \() p
(unsigned) k
( ) p
(char) k
( * ptr, ) p
(unsigned) k
( ) p
(long) k
( off\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(int) k
( idx, bit;) p n
(  idx = \() S
(unsigned) k
( ) p
(int) k
(\) \(off / 8\);) p n
(  bit = 7 - \(\() S
(unsigned) k
( ) p
(int) k
(\) \(off % 8\)\);) p n
(  ) S
(return) K
( \(ptr [idx] & \(1 << bit\)\) >> bit;) p n
(}) N
() N
(int) k
( getval \() p
(unsigned) k
( ) p
(char) k
( * ptr, ) p
(unsigned) k
( ) p
(long) k
( off, ) p
(int) k
( bits\)) p n
({) N
(  ) S
(int) k
( result, i;) p n
(  result = 0;) N
(  ) S
(for) K
( \(i = 0; i < bits; i++\)) p n
(    result |= getbit \(ptr, off + i\) << \(bits - i - 1\);) N
(  ) S
(return) K
( result;) p n
(}) N
() N
(/*) c n
(  src is a pointer to an array of unsigned chars which is the output) N
(  of RLEencode.  dst is a pointer to an empty buffer of size dLen.) N
(video.c) (Page 1/3) (May 15, 98 9:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  RLEdecode will decompress the data into dst, stopping short if it) c n
(  is about to exceed the length of the buffer.  If the buffer is too) N
(  long the remaining space may be filled with junk.) N
( */) N
(  ) p n
(void) k
( RLEdecode\() p
(unsigned) k
( ) p
(char) k
( * src, ) p
(unsigned) k
( ) p
(char) k
( * dst, ) p
(int) k
( dLen\)) p n
({) N
(  ) S
(int) k
( sPtr=0, dPtr=0, x;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( count, c;) p n
(  ) S
(while) K
(\(dPtr<dLen\)) p n
(    {) N
(      ) S
(if) K
( \(getbit\(src,sPtr\)==0\)) p n
() S 8 T ({) N
() S 8 T (  sPtr++;) N
() S 8 T (  dst[dPtr]=getval\(src,sPtr,4\);) N
() S 8 T (  dPtr++;) N
() S 8 T (  sPtr+=4;) N
() S 8 T (}) N
(      ) S
(else) K n
() p 8 T ({) N
() S 8 T (  sPtr++;) N
() S 8 T (  c=getval\(src,sPtr,4\);) N
() S 8 T (  sPtr+=4;) N
() S 8 T (  count=getval\(src,sPtr,5\);) N
() S 8 T (  sPtr+=5;) N
() S 8 T (  ) S
(for) K
(\(x=dPtr;\(x<dPtr+count+2\)&&\(x<dLen\);x++\)) p n
() S 8 T (    {) N
() S 8 T (      dst[x]=c;) N
() S 8 T (    }) N
() S 8 T (  dPtr=x;) N
() S 8 T (}) N
(    }) N
(}) N
() N
(/* Video Init routine.  Registers video handler with serial interface */) c n
() p n
(void) k
( handleVideo\(packet * p\);) p n
() N
(void) k
( initVideo\(\)) p n
({) N
(  registerhandler\(VIDEO, \(packethandler\) handleVideo\);) N
(}) N
() N
(#define) K
( frameBufferSz 19200) p n
() N
(/* Declare buffer for incoming data */) c n
() p n
(unsigned) k
( ) p
(char) k
( incoming[frameBufferSz+1];) p n
() N
(/* Declare buffer for XORing data */) c n
() p n
(unsigned) k
( ) p
(char) k
( out[2][frameBufferSz];) p n
() N
(/* Video handler */) c n
() p n
(void) k
( handleVideo\(packet * p\)) p n
({) N
(  ) S
(int) k
( x, y, *a, *b, *c;) p n
(  ) S
(static) K
( ) p
(int) k
( current=0, last=1;) p n
(  RLEdecode\(&\(p->data[1]\), incoming, frameBufferSz\);) N
() N
(  ) S
(/* If this is the first frame in a sequence then reset the previous frame */) c n
(video.c) (Page 2/3) (May 15, 98 9:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/video.c) (31/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3,1) 32
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(if) K
( \(p->data[0]==1\)) p n
(    {) N
(      printf\(") S
(**First frame in image\\n) str
("\);) p n
(      ) S
(for) K
(\(x=0;x<19200;x++\)) p n
() S 8 T (out[last][x]=0;) N
(    }) N
() N
(  ) S
(/* XOR uncompressed data with previous frame to obtain new image */) c n
() p n
(  ) S
(for) K
( \(x = 0; x < 19200; x++\)) p n
(    out [current][x] = incoming [x] ^ out [last][x];) N
(  display_image\(out[current]\);) N
(  ) N
(  ) S
(/* Reverse what is current and what is last */) c n
(  current=1-current;) p n
(  last=1-last;) N
(}) N
(video.c) (Page 3/3) (May 15, 98 9:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* xpm.c */) c n
(/* Functions for conversion to xpm & doubling */) N
() p n
(#include) K
( <stdlib.h>) p n
(#include) K
( ") p
(xpm.h) str
(") p n
() N
(/* Frees any allocated memory */) c n
(void) k
( free_mem\(\)) p n
({) N
(  ) S
(int) k
( i;) p n
() N
(  ) S
(for) K
(\(i=0;i<XPM_LINES;i++\){) p n
(    ) S
(if) K
(\(xpm[i]\) free\(xpm[i]\);) p n
(  }) N
(  ) S
(if) K
(\(xpm\) free\(xpm\);) p n
(}) N
() N
(void) k
( clean_exit\() p
(char) k
( *text\)) p n
({) N
(  free_mem\(\);) N
(  printf\(") S
(%s\\n) str
(",text\);) p n
(  exit\(1\);) N
(}) N
() N
(/* init_xpm\(\) : Allocates memory for xpm data. Must be called *once*) c n
( * before double_xpm) N
( */) N
(void) k
( init_xpm\(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(/* allocate mem for array of str pointers */) c n
(  xpm = calloc\(XPM_LINES,) p
(sizeof) K
(\() p
(char) k
( *\)\);) p n
(  ) S
(if) K
(\(!xpm\) clean_exit\(") p
(malloc problem) str
("\);) p n
(  ) N
(  ) S
(/* allocate each string */) c n
(  ) p
(for) K
(\(i=0;i<XPM_LINES;i++\){) p n
(    xpm[i] = \() S
(char) k
( *\)calloc\(XPM_WIDTH,) p
(sizeof) K
(\() p
(char) k
(\)\);) p n
(    ) S
(if) K
(\(!xpm[i]\) clean_exit\(") p
(malloc problem) str
("\);) p n
(  }) N
(  printf\(") S
(Allocated xpm memory\\n) str
("\);) p n
() N
(  ) S
(/* copy colourmap/infoline  - this never changes */) c n
(  strcpy\(xpm[0],") p
(320 239 16 1) str
("\);) p n
(  strcpy\(xpm[1],") S
(0 c #000000) str
("\);) p n
(  strcpy\(xpm[2],") S
(1 c #111111) str
("\);) p n
(  strcpy\(xpm[3],") S
(2 c #222222) str
("\);) p n
(  strcpy\(xpm[4],") S
(3 c #333333) str
("\);) p n
(  strcpy\(xpm[5],") S
(4 c #444444) str
("\);) p n
(  strcpy\(xpm[6],") S
(5 c #555555) str
("\);) p n
(  strcpy\(xpm[7],") S
(6 c #666666) str
("\);) p n
(  strcpy\(xpm[8],") S
(7 c #777777) str
("\);) p n
(  strcpy\(xpm[9],") S
(8 c #888888) str
("\);) p n
(  strcpy\(xpm[10],") S
(9 c #999999) str
("\);) p n
(  strcpy\(xpm[11],") S
(A c #aaaaaa) str
("\);) p n
(  strcpy\(xpm[12],") S
(B c #bbbbbb) str
("\);) p n
(  strcpy\(xpm[13],") S
(C c #cccccc) str
("\);) p n
(  strcpy\(xpm[14],") S
(D c #dddddd) str
("\);) p n
(  strcpy\(xpm[15],") S
(E c #eeeeee) str
("\);) p n
(  strcpy\(xpm[16],") S
(F c #ffffff) str
("\);) p n
(  auto_col = 0;) N
(}) N
() N
(xpm.c) (Page 1/2) (May 15, 98 9:22) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/video.c, linux/xpm.c) (32/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2,1) 33
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Double_xpm : Expands xpm to double its size and returns a pointer) c n
(   to the new xpm */) N
() p n
(void) k
( double_xpm\() p
(char) k
( *image_data\)) p n
({) N
() N
(  ) S
(char) k
( temp_char[XPM_WIDTH];) p n
(  ) S
(int) k
( yindex=0,xindex=0,data_count,c;) p n
(  ) S
(char) k
( temp[] = ") p
( ) str
(";  ) p
(/* for transferring a char to a string */) c n
() p n
(  auto_col++;) N
(  ) S
(/* copy pixel data but doubling width and height */) c n
(  ) p
(for) K
(\(data_count = 0;data_count < IMAGE_DATA_SIZE;data_count++\){) p n
(    ) S
(/* on end of line... */) c n
(    ) p
(if) K
(\(xindex == XPM_WIDTH\){) p n
(      xindex = 0;) N
(      ) S
(/* double vertically */) c n
(      strcpy\(xpm[XPM_DATA_OFFSET+yindex+1],xpm[XPM_DATA_OFFSET+yindex]\);) p n
(      yindex+=2;) N
(    }) N
(    ) N
(    ) S
(/* display a blank image if we have no image pointer */) c n
(    ) p
(if) K
(\(image_data\) c = image_data[data_count]; ) p n
(    ) S
(else) K
( c =  auto_col;) p n
(    ) N
(    ) S
(/* convert to HEX */) c n
(    ) p
(if) K
( \(c < 10\)) p n
(      c = c + ') S
(0) str
(';) p n
(    ) S
(else) K n
(      c = c + ') p
(A) str
(' - 10;) p n
() N
(    xpm[yindex+XPM_DATA_OFFSET][xindex] = c;) N
(    xpm[yindex+XPM_DATA_OFFSET][xindex+1] = c;) N
(    xindex+=2;) N
(  }) N
(}) N
() N
(/* diagnostic. Prints XPM to stdout */) c n
(void) k
( output_xpm\(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(for) K
(\(i=0;i<XPM_LINES;i++\){) p n
(    printf\(") S
(\\"%s\\",\\n) str
(",xpm[i]\);) p n
(  }) N
(  exit\(1\);) N
(}) N
() N
(xpm.c) (Page 2/2) (May 15, 98 9:22) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <m68kboard.h>) p n
(#include) K
( <support.h>) p n
(#include) K
( <board.h>) p n
() N
(volatile) K
( ) p
(struct) k
( mc68230fm * spit = \() p
(volatile) K
( ) p
(struct) k
( mc68230fm *\)) p n
(     0x05000000;) N
() N
(/* Secondary 230 port layout:) c n
(     - port A: bits 7-6, DAC control; bit 5, iButton; bit 4, keypad) N
(               control; bits 3-0, keypad data) N
(     - port B: DAC/ADC data) N
(     - port C: bits 1-0, buzzer and LEDs) N
(*/) N
() p n
(/* Initialise the board */) c n
(void) k
( boardinit \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Set up timer - PC3/TOUT carries TOUT, CLK and the prescaler are) c n
(     used, and the timer is disabled */) N
(  spit->tcr = 0x42;) p n
(  ) S
(/* Set up port A  - top three lines are outputs */) c n
(  spit->ddra = 0xE0;) p n
(  ) S
(/* Set up port C - bottom two lines are outputs */) c n
(  spit->ddrc = 0x03;) p n
(}) N
() N
(/* Timer functions - one timer tick occurs every 3.2us */) c n
() p n
(/* Start the timer */) c n
(void) k
( starttimer \() p
(int) k
( count\)) p n
({) N
(  ) S
(/* Disable the timer */) c n
(  spit->tcr = 0x42;) p n
(  ) S
(/* Load the preloads */) c n
(  spit->cph = \(count & 0x00FF0000\) >> 16;) p n
(  spit->cpm = \(count & 0x0000FF00\) >> 8;) N
(  spit->cpl = count & 0x000000FF;) N
(  ) S
(/* Enable the timer */) c n
(  spit->tcr = 0x43;) p n
(}) N
() N
(/* Stop the timer */) c n
(int) k
( stoptimer \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Disable the timer */) c n
(  spit->tcr = 0x42;) p n
(  ) S
(/* Return the current count */) c n
(  ) p
(return) K
( gettimer \(\);) p n
(}) N
() N
(/* Get the current timer value */) c n
(inline) K
( ) p
(int) k
( gettimer \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Return the current count */) c n
(  ) p
(return) K
( \(\(\() p
(int) k
(\) spit->crh << 16\) + \(\() p
(int) k
(\) spit->crm << 8\) + \() p
(int) k
(\)) p n
() S 8 T (  spit->crl\);) N
(}) N
() N
(/* Keycode translation table */) c n
(unsigned) k
( ) p
(char) k
( kptable[] = { 1, 2, 3, KP_DOORBELL,) p n
() S 8 T () S 16 T () S 24 T (    4, 5, 6, KP_UNDEF,) N
() S 8 T () S 16 T () S 24 T (    7, 8, 9, KP_UNDEF,) N
(board.c) (Page 1/7) (May 14, 98 23:30) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(linux/xpm.c, motorola/board.c) (33/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2-3) 34
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T () S 16 T () S 24 T (    KP_STAR, 0, KP_HASH, KP_UNDEF };) N
() N
(/* Get a keypad digit */) c n
(unsigned) k
( ) p
(char) k
( getkeypad \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Initialise port A direction */) c n
(  spit->ddra = 0xC0;) p n
() N
(  ) S
(/* Wait for a key to be pressed */) c n
(  ) p
(while) K
( \(!\(spit->ara & 0x10\)\);) p n
() N
(  ) S
(/* Wait for the key to be released */) c n
(  ) p
(while) K
( \(spit->ara & 0x10\);) p n
() N
(  ) S
(/* Get the key, convert it and return */) c n
(  ) p
(return) K
( kptable [spit->ara & 0x0F];) p n
(}) N
() N
(/* Check whether a key is pressed */) c n
(int) k
( checkkeypad \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Set port A direction */) c n
(  spit->ddra = 0xC0;) p n
() N
(  ) S
(/* Check and return */) c n
(  ) p
(return) K
( \(spit->ara & 0x10\);) p n
(}) N
() N
(/* Activate buzzer and LEDs, according to above */) c n
(int) k
( buzzerled \() p
(int) k
( what\)) p n
({) N
(  ) S
(switch) K
( \(what\)) p n
(    {) N
(    ) S
(case ) K
(ALLOFF) l
(:) p n
(      ) S
(/* Everything off */) c n
(      spit->drc = 0xFF;) p n
(      ) S
(break) K
(;) p n
(    ) S
(case ) K
(BUZZER) l
(:) p n
(      ) S
(/* Buzzer */) c n
(      spit->drc = 0xFD;) p n
(      ) S
(break) K
(;) p n
(    ) S
(case ) K
(LEDGREEN) l
(:) p n
(      ) S
(/* Green LED */) c n
(      spit->drc = 0xFC;) p n
(      ) S
(break) K
(;) p n
(    ) S
(case ) K
(LEDRED) l
(:) p n
(      ) S
(/* Red LED */) c n
(      spit->drc = 0xFE;) p n
(      ) S
(break) K
(;) p n
(    }) N
() N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Return door status */) c n
(int) k
( getdoorstatus \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( olddrc;) p n
(  olddrc = spit->drc;) N
(  spit->drc = olddrc;) N
(  ) S
(return) K
( \(\(olddrc & 0x40\) >> 6\);) p n
(}) N
(board.c) (Page 2/7) (May 14, 98 23:30) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* Open the door */) c n
(int) k
( opendoor \() p
(void) k
(\)) p n
({) N
(  buzzerled \(LEDGREEN\);) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Closes the door */) c n
(int) k
( closedoor \() p
(void) k
(\)) p n
({) N
(  buzzerled \(ALLOFF\);) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* LED codes - not all tested, alphabetic ones are probably wrong \('b' ) c n
(   certainly is :-\) */) N
() p n
(#define) K
( LEDCODES 37) p n
() N
(unsigned) k
( ) p
(char) k
( ledcodes [] =) p n
({) N
(  ') S
(0) str
(', 0xC0,) p n
(  ') S
(1) str
(', 0xF9,) p n
(  ') S
(2) str
(', 0xA4,) p n
(  ') S
(3) str
(', 0xB0,) p n
(  ') S
(4) str
(', 0x99,) p n
(  ') S
(5) str
(', 0x92,) p n
(  ') S
(6) str
(', 0x82,) p n
(  ') S
(7) str
(', 0xF8,) p n
(  ') S
(8) str
(', 0x80,) p n
(  ') S
(9) str
(', 0x98,) p n
(  ') S
( ) str
(', 0xFF,) p n
(  ') S
(a) str
(', 0xDF,) p n
(  ') S
(b) str
(', 0xFC,) p n
(  ') S
(c) str
(', 0xD8,) p n
(  ') S
(d) str
(', 0xDE,) p n
(  ') S
(e) str
(', 0xFB,) p n
(  ') S
(f) str
(', 0xF1,) p n
(  ') S
(g) str
(', 0xEF,) p n
(  ') S
(h) str
(', 0xF4,) p n
(  ') S
(i) str
(', 0x90,) p n
(  ') S
(j) str
(', 0x8C,) p n
(  ') S
(k) str
(', 0xF6,) p n
(  ') S
(l) str
(', 0xB0,) p n
(  ') S
(m) str
(', 0xD4,) p n
(  ') S
(n) str
(', 0xD4,) p n
(  ') S
(o) str
(', 0xDC,) p n
(  ') S
(p) str
(', 0xF3,) p n
(  ') S
(q) str
(', 0xE7,) p n
(  ') S
(r) str
(', 0xD0,) p n
(  ') S
(s) str
(', 0xED,) p n
(  ') S
(t) str
(', 0xF8,) p n
(  ') S
(u) str
(', 0x9C,) p n
(  ') S
(v) str
(', 0x9C,) p n
(  ') S
(w) str
(', 0x9C,) p n
(  ') S
(x) str
(', 0xF6,) p n
(  ') S
(y) str
(', 0xEE,) p n
(  ') S
(z) str
(', 0xA4) p n
(};) N
() N
(/* Display the given character on the IDP's LED */) c n
(board.c) (Page 3/7) (May 14, 98 23:30) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/board.c) (34/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (4-5) 35
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( leddisplay \() p
(unsigned) k
( ) p
(char) k
( c\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( * ledreg = \() p
(unsigned) k
( ) p
(char) k
( *\) 0x00D00003;) p n
() N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(LED: ) str
("\);) p n
(  mon_putc \(c\);) N
(  puts \(") S
(\\n\\r) str
("\);) p n
(#endif) K n
(  ) p
(/* Search for the correct code to display */) c n
(  ) p
(for) K
( \(i = 0; i < LEDCODES; i++\)) p n
(    ) S
(if) K
( \(ledcodes [2 * i] == c\)) p n
(      *ledreg = ledcodes [2 * i + 1];) N
(}) N
() N
(/* Note that the CRC-8 functionality isn't yet functional - the CRC-8) c n
(   code is in theory correct \(it's adapted from standard CRC-8 code\),) N
(   but the order in which to perform the calculations for the iButton) N
(   isn't certain. */) N
() p n
(/* Ring CRC-8 */) c n
(unsigned) k
( ) p
(char) k
( __ringcrc;) p n
() N
(/* Check whether an iButton is present */) c n
(int) k
( checkring \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( t, i, r;) p n
() N
(  ) S
(for) K
( \(i = 0; i < 50; i++\)) p n
(    {) N
(      ) S
(/* Set to output, expecting high */) c n
(      spit->dra = 0xE0;) p n
(      spit->ddra = 0xE0;) N
(      starttimer \(10000000\);) N
(      ) S
(/* Pull low */) c n
(      spit->dra = 0xC0;) p n
(      ) S
(/* Start the timer and wait for 480 us */) c n
(      ) p
(while) K
( \(gettimer \(\) > 10000000 - 150\);) p n
(      ) S
(/* Set to input */) c n
(      spit->ddra = 0xC0;) p n
(      ) S
(/* Get current time */) c n
(      t = gettimer \(\);) p n
(      ) S
(/* Wait for high */) c n
(      ) p
(while) K
( \(!\(spit->ara & 0x20\)\);) p n
(      ) S
(/* Wait for low or 960 us */) c n
(      ) p
(while) K
( \(\(spit->ara & 0x20\) && \(\(t - gettimer \(\)\) < 300\)\);) p n
(      ) S
(/* If low, found ring */) c n
(      ) p
(if) K
( \(!\(spit->ara & 0x20\)\)) p n
() S 8 T (r = 1;) N
(      ) S
(/* Otherwise, no ring */) c n
(      ) p
(else) K n
() p 8 T (r = 0;) N
(      ) S
(while) K
( \(\(t - gettimer \(\)\) < 300\);) p n
(      stoptimer \(\);) N
(      ) S
(if) K
( \(r\)) p n
() S 8 T () S
(return) K
( 1;) p n
(    }) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Write a 1 */) c n
(board.c) (Page 4/7) (May 14, 98 23:30) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(void) k
( ringwriteone \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Set to output, expecting high */) c n
(  spit->dra = 0xE0;) p n
(  spit->ddra = 0xE0;) N
(  starttimer \(10000000\);) N
(  ) S
(/* Pull low for 10 us - this works... */) c n
(  spit->dra = 0xC0;) p n
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  ) S
(/* Set to input */) c n
(  spit->ddra = 0xC0;) p n
(  ) S
(/* Wait for a total of 120 us */) c n
(  ) p
(while) K
( \(gettimer \(\) > 10000000 - 40\);) p n
(}) N
() N
(/* Write a 0 */) c n
(void) k
( ringwritezero \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Set to output, expecting high */) c n
(  spit->dra = 0xE0;) p n
(  spit->ddra = 0xE0;) N
(  starttimer \(10000000\);) N
(  ) S
(/* Pull low - again, this works... */) c n
(  spit->dra = 0xC0;) p n
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  ) S
(/* Set to input */) c n
(  spit->ddra = 0xC0;) p n
(  ) S
(/* Wait for a total of 120 us */) c n
(  ) p
(while) K
( \(gettimer \(\) > 10000000 - 40\);) p n
(}) N
() N
(/* Write a byte */) c n
(void) k
( ringwritebyte \() p
(unsigned) k
( ) p
(char) k
( c\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(for) K
( \(i = 0; i < 8; i++\)) p n
(board.c) (Page 5/7) (May 14, 98 23:30) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/board.c) (35/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (6-7) 36
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    {) p n
(      ) S
(if) K
( \(c & \(1 << i\)\)) p n
() S 8 T (ringwriteone \(\);) N
(      ) S
(else) K n
() p 8 T (ringwritezero \(\);) N
(    }) N
(}) N
() N
(/* Read a bit */) c n
(int) k
( ringreadbit \() p
(int) k
( updcrc\)) p n
({) N
(  ) S
(int) k
( t, r;) p n
(  ) N
(  ) S
(/* Set to output, expecting high */) c n
(  spit->dra = 0xE0;) p n
(  spit->ddra = 0xE0;) N
(  starttimer \(10000000\);) N
(  ) S
(/* Pull low */) c n
(  spit->dra = 0xC0;) p n
(  spit->dra = 0xC0;) N
(  spit->dra = 0xC0;) N
(  ) S
(/* Set to input */) c n
(  spit->ddra = 0xC0;) p n
(  ) S
(/* If high, 1 */) c n
(  ) p
(if) K
( \(spit->ara & 0x20\)) p n
(    r = 1;) N
(  ) S
(else) K n
(    r = 0;) p n
(  ) S
(/* Wait for a total of 120 us */) c n
(  ) p
(while) K
( \(gettimer \(\) > 10000000 - 40\);) p n
(  stoptimer \(\);) N
(  ) S
(/* Non-functional CRC code */) c n
(  ) p
(if) K
( \(updcrc\)) p n
(    {) N
(      t = __ringcrc & 0x80;) N
(      __ringcrc = \(__ringcrc << 1\) + r;) N
(      ) S
(if) K
( \(t\)) p n
() S 8 T (__ringcrc ^= 0x18;) N
(    }) N
(  ) S
(return) K
( r;) p n
(}) N
() N
(/* Read a byte */) c n
(unsigned) k
( ) p
(char) k
( ringreadbyte \() p
(int) k
( updcrc\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(char) k
( c;) p n
(  ) S
(int) k
( i;) p n
() N
(  c = 0;) N
(  ) S
(for) K
( \(i = 0; i < 8; i++\)) p n
(    ) S
(if) K
( \(ringreadbit \(updcrc\)\)) p n
(      c |= \(1 << i\);) N
(  ) S
(return) K
( c;) p n
(}) N
() N
(/* CRC-8 calculations - calculated backwards to cope with the) c n
(   iButton's LSB to MSB operation; doesn't work */) N
(unsigned) k
( ) p
(char) k
( crc8 \() p
(unsigned) k
( ) p
(char) k
( crc, ) p
(unsigned) k
( ) p
(char) k
( value\)) p n
({) N
(  ) S
(int) k
( shiftreg, shiftcrc, i;) p n
(  shiftreg = value;) N
(  shiftcrc = crc;) N
(board.c) (Page 6/7) (May 14, 98 23:30) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(for) K
( \(i = 0; i < 8; i++\)) p n
(    {) N
(      ) S
(if) K
( \(value & \(1 << i\)\)) p n
() S 8 T (shiftcrc = \(shiftcrc << 1\) | 1;) N
(      ) S
(else) K n
() p 8 T (shiftcrc = \(shiftcrc << 1\) & ~1;) N
(      ) S
(if) K
( \(shiftcrc & 0x00000100\)) p n
() S 8 T (shiftcrc ^= 0x00000031;) N
(    }) N
(  ) S
(return) K
( \() p
(unsigned) k
( ) p
(char) k
(\) \(shiftcrc & 0x000000FF\);) p n
(}) N
() N
(/* Retrieve the ring information; will check up to five times to cope) c n
(   with read errors \(CRC == 0xFF\) */) N
(ringinfo getringinfo \() p
(void) k
(\)) p n
({) N
(  ringinfo ri;) N
(  ) S
(int) k
( i, j;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( buf [8];) p n
() N
(  ) S
(/* If there is a ring \(this also resets it\) ... */) c n
(  ) p
(if) K
( \(checkring \(\)\)) p n
(    {) N
(      j = 0;) N
(      ri.crc = 0xFF;) N
() N
(      ) S
(/* Check up to five times */) c n
(      ) p
(while) K
( \(j < 5 && ri.crc == 0xFF\)) p n
() S 8 T ({) N
() S 8 T (  ) S
(/* Send read command */) c n
() p 8 T (  ringwritebyte \(0x0F\);) N
() S 8 T (  ) S
(/* Get product code */) c n
() p 8 T (  ri.product = ringreadbyte \(1\);) N
() S 8 T (  ) S
(/* Get iButton ID */) c n
() p 8 T (  ) S
(for) K
( \(i = 5; i >= 0; i--\)) p n
() S 8 T (    ri.id [i] = ringreadbyte \(1\);) N
() S 8 T (  ) S
(/* Get CRC */) c n
() p 8 T (  ri.crc = ringreadbyte \(0\);) N
() S 8 T (  j++;) N
() S 8 T (};) N
(    }) N
(  ) S
(return) K
( ri;) p n
(}) N
(board.c) (Page 7/7) (May 14, 98 23:30) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/board.c) (36/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 37
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Functions for database receive \(Motorola end\) via serial line */) c n
(/* Edward Knowelden */) N
() p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( ") p
(../dbm_defs.h) str
(") p n
() N
(extern) K
( local_db_item db_local_store[MAX_USERS];) p n
() N
(/* request_db  ) c n
(   Called on powerup of motorola board. Asks Linux box to) N
(   send database. */) N
() p n
(int) k
( request_db\(\)) p n
({) N
(  ) S
(char) k
( data[4];) p n
(  packet p,next,*rcp;) N
(  datatype_t datatp;) N
(  ) S
(int) k
( record = 0;) p n
() N
(  puts\(") S
(Requesting DB\\n\\r) str
("\);) p n
(  ) S
(/* send request message */) c n
(  itos\(REQUEST_DBDL,data,4\);) p n
(  datatp = DATABASE;) N
(  p.datatype = datatp;) N
(  p.length = 4;) N
(  p.data = data;) N
(  senddata\(&p\);) N
(  ) N
(  ) S
(/* build "next" packet */) c n
(  next.datatype = DATABASE;) p n
(  next.length = 4;) N
(  itos\(REQUEST_NEXT,data,4\);) N
(  next.data = data;) N
() N
(  ) S
(/* now receive the data. At present, database is split into) c n
(     separate packets for each record */) N
(  ) p
(while) K
( \(1\) {) p n
(#if) K
( 0) p n
(    puts\(") S
(Waiting for data packet\\n\\r) str
("\);) p n
(#endif) K n
(    rcp = receivepacket\(\);) p n
(    ) S
(if) K
(\(rcp->data[0] == 0xFF\) ) p
(break) K
(;) p n
(    ) S
(/* copy data out of packet */) c n
(    strcopy\(db_local_store[record].uid,rcp->data\);) p n
(    strcopy\(db_local_store[record].pin,\(rcp->data\)+) S
(sizeof) K
(\() p
(char) k
([UID_SIZE+1]\)\);) p n
(    puts\(") S
(Recieved) str
("\); ) p n
(    puts\(db_local_store[record].uid\);) N
(    puts\(") S
( ) str
("\);) p n
(    puts\(db_local_store[record].pin\);) N
(    puts\(") S
(\\n\\r) str
("\);) p n
(    record++;) N
(    ) S
(/* send a signal that we are ready for the next packet */) c n
(    senddata\(&next\);) p n
(  }) N
(  ) N
(  ) S
(/* add eof record */) c n
(  strcopy\(db_local_store[record].uid,") p
(X) str
("\);) p n
(}) N
() N
(/* Called by SERIAL_TRANSPORT when it has some data for the database */) c n
(void) k
( handle_db_data\(packet p\)) p n
({) N
(db_recieve.c) (Page 1/2) (May 15, 98 8:52) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(int) k
( i,j,rsize;) p n
() N
(  ) S
(/* calculate record size \(+2 for 2 NULL chars\)*/) c n
(  rsize = UID_SIZE+PIN_SIZE+2;) p n
() N
(  puts\(") S
(\\nExtracting packet...) str
("\);) p n
(    ) S
(/*...\(%i records\)\\n",\(p.length/sizeof\(db_item\)\)\);*/) c n
(  ) p
(/* extract data from packet into memory */) c n
(  ) p
(for) K
(\(i=0; i < \(p.length/) p
(sizeof) K
(\(db_item\)\); i++\){) p n
(    ) S
(/* first 12 bytes are uid */) c n
(    ) p
(for) K
(\(j=0;j<UID_SIZE+1;j++\){) p n
(      db_local_store[i].uid[j] = *\(p.data+\(rsize*i\)+j\);) N
(    }) N
(    puts\(") S
(uid: ) str
("\); ) p n
(    puts\(db_local_store[i].uid\);) N
() N
(    ) S
(/* next 4 are PIN */) c n
(    ) p
(for) K
(\(j=0;j<PIN_SIZE+1;j++\){) p n
(      db_local_store[i].pin[j] = *\(p.data+\(rsize*i\)+UID_SIZE+1+j\);) N
(    }) N
(    puts\(") S
(pin: ) str
("\); ) p n
(    puts\(db_local_store[i].pin\);) N
(  }) N
(}) N
() N
() N
(db_recieve.c) (Page 2/2) (May 15, 98 8:52) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/db_recieve.c) (37/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 38
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Hardware diagnostics program) c n
(   Stephen Kitt) N
(*/) N
() p n
(#include) K
( <board.h>) p n
() N
(void) k
( main \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( k;) p n
(  ringinfo ri;) N
(  ) N
(  puts \(") S
(G7 hardware diagnostics\\n\\r) str
("\);) p n
() N
(  puts \(") S
(\\n\\rInitialising board...) str
("\);) p n
(  boardinit \(\);) N
(  puts \(") S
( done\\n\\r) str
("\);) p n
() N
(  puts \(") S
(\\n\\r ** Timer test\\n\\r) str
("\);) p n
(  puts \(") S
(Waiting for 3 seconds...) str
("\);) p n
(  starttimer \(1010000\);) N
(  ) S
(while) K
( \(gettimer \(\) > 10000\);) p n
(  puts \(") S
( done\\n\\r) str
("\);) p n
() N
(  puts \(") S
(\\n\\r ** iButton reader test\\n\\r) str
("\);) p n
(  puts \(") S
(Place an iButton in the reader...\\n\\r) str
("\);) p n
(  i = 0;) N
(  ) S
(do) K n
(    {) p n
(      ) S
(while) K
( \(!checkring \(\)\);) p n
(      ri = getringinfo \(\);) N
(      i++;) N
(    }) N
(  ) S
(while) K
( \(ri.crc == 0xFF\);) p n
(  puts \(") S
(iButton read \() str
("\);) p n
(  putn \(i, 10, 2\);) N
(  puts \(") S
( times\); product family ) str
("\);) p n
(  putn \(ri.product, 16, 2\);) N
(  puts \(") S
(; user ID ) str
("\);) p n
(  ) S
(for) K
( \(i = 0; i < 6; i++\)) p n
(    putn \(ri.id [i], 16, 2\);) N
(  puts \(") S
(; CRC ) str
("\);) p n
(  putn \(ri.crc, 16, 2\);) N
(  puts \(") S
(\\n\\r) str
("\);) p n
() N
(  puts \(") S
(\\n\\r ** Keypad test\\n\\r) str
("\);) p n
(  puts \(") S
(Press all the keys and the doorbell...\\n\\r) str
("\);) p n
(  ) S
(for) K
( \(i = 0; i < 13; i++\)) p n
(    {) N
(      k = getkeypad \(\);) N
(      starttimer \(40000\);) N
(      buzzerled \(BUZZER\);) N
(      ) S
(while) K
( \(gettimer \(\) > 10000\);) p n
(      buzzerled \(ALLOFF\);) N
(      stoptimer \(\);) N
(      puts \(") S
(Key pressed: ) str
("\);) p n
(      ) S
(if) K
( \(k < 10\)) p n
() S 8 T (putn \(k, 10, 1\);) N
(      ) S
(else) K n
() p 8 T () S
(switch) K
( \(k\)) p n
() S 8 T (  {) N
() S 8 T (  ) S
(case ) K
(KP_STAR) l
(:) p n
(harddiag.c) (Page 1/3) (May 14, 98 23:43) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T (    puts \(") S
(*) str
("\);) p n
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  ) S
(case ) K
(KP_HASH) l
(:) p n
() S 8 T (    puts \(") S
(#) str
("\);) p n
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  ) S
(case ) K
(KP_DOORBELL) l
(:) p n
() S 8 T (    puts \(") S
(doorbell) str
("\);) p n
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  ) S
(case ) K
(KP_UNDEF) l
(:) p n
() S 8 T (    puts \(") S
(undefined \() str
("\);) p n
() S 8 T (    putn \(k, 16, 2\);) N
() S 8 T (    puts \(") S
(\)) str
("\);) p n
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  }) N
(      puts \(") S
(\\n\\r) str
("\);) p n
(    }) N
() N
(  puts \(") S
(\\n\\r ** Beeper test\\n\\r) str
("\);) p n
(  starttimer \(10000000\);) N
(  buzzerled \(BUZZER\);) N
(  ) S
(while) K
( \(gettimer \(\) > 10000000 - 30000\);) p n
(  buzzerled \(ALLOFF\);) N
(  ) S
(while) K
( \(gettimer \(\) > 10000000 - 40000\);) p n
(  buzzerled \(BUZZER\);) N
(  ) S
(while) K
( \(gettimer \(\) > 10000000 - 70000\);) p n
(  buzzerled \(ALLOFF\);) N
(  stoptimer \(\);) N
() N
(  puts \(") S
(\\n\\r ** Door open test\\n\\r) str
("\);) p n
(  ) S
(for) K
( \(i = 0; i < 5; i++\)) p n
(    {) N
(      starttimer \(210000\);) N
(      buzzerled \(LEDGREEN\);) N
(      ) S
(while) K
( \(gettimer \(\) > 110000\);) p n
(      buzzerled \(ALLOFF\);) N
(      ) S
(while) K
( \(gettimer \(\) > 10000\);) p n
(      stoptimer \(\);) N
(    }) N
() N
(  puts \(") S
(\\n\\r ** Entry denied test\\n\\r) str
("\);) p n
(  ) S
(for) K
( \(i = 0; i < 5; i++\)) p n
(    {) N
(      starttimer \(210000\);) N
(      buzzerled \(LEDRED\);) N
(      ) S
(while) K
( \(gettimer \(\) > 110000\);) p n
(      buzzerled \(ALLOFF\);) N
(      ) S
(while) K
( \(gettimer \(\) > 10000\);) p n
(      stoptimer \(\);) N
(    }) N
() N
(  puts \(") S
(\\n\\r ** Door status test\\n\\r) str
("\);) p n
(  puts \(") S
(Close the door, then press a key\\n\\r) str
("\);) p n
(  mon_getc \(\);) N
(  puts \(") S
(Door status is ) str
("\);) p n
(  putn \(getdoorstatus \(\), 10, 1\);) N
(  puts \(") S
(\\n\\r) str
("\);) p n
(  puts \(") S
(Open the door, then press a key\\n\\r) str
("\);) p n
(  mon_getc \(\);) N
(  puts \(") S
(Door status is ) str
("\);) p n
(  putn \(getdoorstatus \(\), 10, 1\);) N
(  puts \(") S
(\\n\\r) str
("\);) p n
() N
(harddiag.c) (Page 2/3) (May 14, 98 23:43) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/harddiag.c) (38/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3,1) 39
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  puts \(") p
(\\n\\r ** Testing done\\n\\r) str
("\);) p n
(}) N
(harddiag.c) (Page 3/3) (May 14, 98 23:43) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Support functions for motorola board */) c n
() p n
(/* Simple strcmp function for motorola */) c n
(/* Not the same as one in string.h - still returns 0 if strings are the) N
( * same and 1 otherwise. ) N
( */) N
() p n
() N
(int) k
( strcomp\() p
(char) k
( *string1,) p
(char) k
( *string2\) ) p n
({) N
(  ) S
(int) k
( index=0;) p n
() N
(  ) S
(while) K
(\( *string1 != ') p
(\\0) str
(' && *string2 != ') p
(\\0) str
('\) {) p n
(    ) S
(if) K
(\(*string1++ != *string2++\) ) p
(break) K
(;) p n
(  }) N
(  ) S
(if) K
(\(*string1 == ') p
(\\0) str
(' && *string2 == ') p
(\\0) str
('\) ) p
(return) K
( 0; ) p
(else) K
( ) p
(return) K
( 1;) p n
(}) N
() N
() N
(/* String copy function for motorola */) c n
(void) k
( strcopy\() p
(char) k
( *to, ) p
(char) k
( *from\)) p n
({) N
(  ) S
(int) k
( index=0;) p n
(  ) N
(  ) S
(while) K
(\(from[index] != ') p
(\\0) str
('\){) p n
(    to[index] = from[index];) N
(    index++;) N
(  }) N
(  to[index] = ') S
(\\0) str
(';) p n
(}) N
(m_support.c) (Page 1/1) (May 15, 98 8:54) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/harddiag.c, motorola/m_support.c) (39/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 40
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <support.h>) p n
() N
(void) k
( putn \() p
(unsigned) k
( ) p
(long) k
( number, ) p
(int) k
( base, ) p
(int) k
( digits\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(long) k
( magnitude;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( digit;) p n
(  ) N
(  magnitude = 1;) N
(  ) S
(while) K
( \(digits > 1\)) p n
(    {) N
(      magnitude *= base;) N
(      digits--;) N
(    };) N
(  ) S
(while) K
( \(magnitude > 0\)) p n
(    {) N
(      digit = number / magnitude;) N
(      ) S
(if) K
( \(digit < 10\)) p n
() S 8 T (mon_putc \(') S
(0) str
(' + digit\);) p n
(      ) S
(else) K n
() p 8 T (mon_putc \(') S
(A) str
(' - 10 + digit\);) p n
(      number %= magnitude;) N
(      magnitude /= base;) N
(    };) N
(}) N
(putn.c) (Page 1/1) (May 14, 98 23:41) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#include) K
( <support.h>) p n
(#include) K
( <m68kboard.h>) p n
() N
(void) k
( puts \() p
(char) k
( * string\)) p n
({) N
(  ) S
(while) K
( \(*string\)) p n
(    {) N
(      mon_putc \(*string\);) N
(      string++;) N
(    }) N
(}) N
(puts.c) (Page 1/1) (May 14, 98 23:41) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/putn.c, motorola/puts.c) (40/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 41
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Motorola serial code, polling version) c n
(   Stephen Kitt) N
(*/) N
() p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( <serial.h>) p n
() N
(/* UART access */) c n
(volatile) K
( ) p
(struct) k
( mc68681wfm * uartw = \() p
(struct) k
( mc68681wfm *\) 0x00B00000; ) p n
(volatile) K
( ) p
(struct) k
( mc68681rfm * uartr = \() p
(struct) k
( mc68681rfm *\) 0x00B00000;) p n
() N
(/* Flags identifying need to acknowledge packet, and packet being sent ) c n
( */) N
(int) k
( __ack, __sendingpacket;) p n
() N
(/* Initialise the DUART channel B, for polled serial */) c n
(int) k
( serialinit \() p
(void) k
(\)) p n
({) N
(  __ack = 0;) N
(  __sendingpacket = 0;) N
(  ) N
(  ) S
(/* Reset ACR */) c n
(  uartw->acr = 0;) p n
(  ) S
(/* Reset MRB pointer */) c n
(  uartw->crb = 0x10;) p n
(  ) S
(/* Setup no parity, 8-bits per character, IRQ on RxRDY */) c n
(  uartw->mr1b = 0x33;) p n
(  ) S
(/* One stop bit */) c n
(  uartw->mr2b = 0x07;) p n
(  ) S
(/* 38.4kbps both ways */) c n
(  uartw->csrb = 0xCC;) p n
(  ) S
(/* Reset receiver, transmitter and error status */) c n
(  uartw->crb = 0x20;) p n
(  uartw->crb = 0x30;) N
(  uartw->crb = 0x40;) N
(  ) S
(/* Enable transmitter and receiver */) c n
(  uartw->crb = 0x05;) p n
() N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Shut the serial down */) c n
(int) k
( serialclose \() p
(void) k
(\)) p n
({) N
(  ) S
(return) K
( 0;) p n
(}) N
() N
(/* Ping the PC */) c n
(int) k
( ping \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( sr;) p n
() N
(  ) S
(/* Prepare packet */) c n
(  packet pkt;) p n
(  pkt.datatype = 1;) N
(  pkt.length = 0;) N
(  pkt.data = 0;) N
() N
(  ) S
(/* Send it */) c n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: sending ping packet, type 1, length 0, data 0\\n\\r) str
("\);) p n
(#endif) K n
(serial.c) (Page 1/4) (May 14, 98 23:32) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  senddata \(&pkt\);) p n
() N
(  ) S
(/* Wait for response; swallowing everything is obviously not) c n
(     ideal... */) N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: waiting for response\\n\\r) str
("\);) p n
(#endif) K n
(  ) p
(do) K n
(    sr = serialreceive \(\);) p n
(  ) S
(while) K
( \(sr != 2 && sr != -1\);) p n
() N
(  ) S
(if) K
( \(sr == 2\)) p n
(    {) N
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Serial: response received\\n\\r) str
("\);) p n
(#endif) K n
(      ) p
(return) K
( 0;) p n
(    }) N
(  ) S
(else) K n
(    {) p n
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Serial: ping timed out\\n\\r) str
("\);) p n
(#endif) K n
(      ) p
(return) K
( -1;) p n
(    }) N
(}) N
() N
(/* Acknowledge a ping and wait for new state */) c n
(int) k
( pingack \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
(  ) N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: ping received, noting need to acknowledge\\n\\r) str
("\);) p n
(#endif) K n
(  ) p
(/* If we're currently sending a packet, we should wait until we've) c n
(     finished */) N
(  ) p
(if) K
( \(__sendingpacket\)) p n
(    {) N
(      __ack = 1;) N
(      ) S
(return) K
( 0;) p n
(    }) N
(  ) S
(/* Otherwise, send it straight away */) c n
(  ) p
(else) K n
(    {) p n
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Serial: acknowledging ping\\n\\r) str
("\);) p n
(#endif) K n
(      serialtransmit \(2\);) p n
(      ) S
(for) K
( \(i = 0; i < 4; i++\)) p n
() S 8 T (serialtransmit \(0\);) N
(      __ack = 0;) N
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Serial: acknowledged, waiting for new state\\n\\r) str
("\);) p n
(#endif) K n
(      ) p
(return) K
( serialreceive \(\);) p n
(    }) N
(}) N
() N
(/* Transmits a single byte of data */) c n
(int) k
( serialtransmit \() p
(unsigned) k
( ) p
(char) k
( value\)) p n
({) N
(serial.c) (Page 2/4) (May 14, 98 23:32) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/serial.c) (41/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3-4) 42
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(int) k
( r = 0;) p n
(  ) S
(/* Wait for TxRDY; if RxRDY and ping happens, get byte and return) c n
(     corresponding value */) N
(  ) p
(while) K
( \(!\(uartr->srb & 0x04\)\);) p n
(  ) S
(/* Transmit character */) c n
(  uartw->tbb = value;) p n
(  ) S
(if) K
( \(\(uartr->srb & 0x01\) && uartr->rbb == 1\)) p n
(    r = pingack \(\);) N
() N
(  ) S
(return) K
( r;) p n
(}) N
() N
(/* Receives a single byte of data */) c n
(int) k
( serialreceive \() p
(void) k
(\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(char) k
( r;) p n
(  ) S
(/* Wait for RxRDY */) c n
(  ) p
(while) K
( \(!\(uartr->srb & 0x01\)\);) p n
(  ) S
(/* Receive character */) c n
(  r = uartr->rbb;) p n
(  ) S
(return) K
( r;) p n
(}) N
() N
(/* Sends a packet of data; doesn't return until the packet's been) c n
(   transmitted */) N
(int) k
( senddata \(packet * out\)) p n
({) N
(  ) S
(int) k
( i;) p n
() N
(  ) S
(/* Say we're sending a packet */) c n
(  __sendingpacket = 1;) p n
() N
(  ) S
(/* Send the datatype */) c n
(  serialtransmit \(out->datatype\);) p n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: sending packet, length ) str
("\);) p n
(  putn \(out->length, 10, 6\);) N
(  puts \(") S
(\\n\\r) str
("\);) p n
(#endif) K n
(  ) p
(/* Send the length */) c n
(  ) p
(for) K
( \(i = 24; i >= 0; i -= 8\)) p n
(    serialtransmit \(\(out->length >> i\) & 0xFF\);) N
(  ) S
(/* Send the data */) c n
(  ) p
(for) K
( \(i = 0; i < out->length; i++\)) p n
(    serialtransmit \(out->data [i]\);) N
() N
(  ) S
(/* We're no longer sending a packet */) c n
(  __sendingpacket = 0;) p n
() N
(  ) S
(/* If we need to acknowledge a ping, do so, and wait for the new) c n
(     state */) N
(  ) p
(if) K
( \(__ack\)) p n
(    {) N
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Serial: acknowledging ping\\n\\r) str
("\);) p n
(#endif) K n
(      serialtransmit \(2\);) p n
(      ) S
(for) K
( \(i = 0; i < 4; i++\)) p n
() S 8 T (serialtransmit \(0\);) N
(      __ack = 0;) N
(#ifdef) K
( DEBUG) p n
(      puts \(") S
(Serial: acknowledged, waiting for new state\\n\\r) str
("\);) p n
(serial.c) (Page 3/4) (May 14, 98 23:32) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(#endif) K n
(      ) p
(return) K
( serialreceive \(\);) p n
(    }) N
(  ) S
(else) K n
(    ) p
(return) K
( 0;) p n
(}) N
() N
(/* Storage for the packet */) c n
(packet pkt;) p n
(unsigned) k
( ) p
(char) k
( pktbuf [32768];) p n
() N
(/* Received a packet; everything must be copied before calling) c n
(   receivepacket again */) N
(packet * receivepacket \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
() N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(Serial: receiving a packet) str
("\);) p n
(#endif) K n
() p n
(  ) S
(/* Get the datatype */) c n
(  pkt.datatype = serialreceive \(\);) p n
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(; datatype ) str
("\);) p n
(  putn \(pkt.datatype, 10, 3\);) N
(#endif) K n
() p n
(  ) S
(/* Get the length */) c n
(  pkt.length = 0;) p n
(  ) S
(for) K
( \(i = 0; i < 4; i++\)) p n
(    pkt.length = \(pkt.length << 8\) + serialreceive \(\);) N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(; length ) str
("\);) p n
(  putn \(pkt.length, 10, 3\);) N
(#endif) K n
() p n
(  ) S
(/* Get the data */) c n
(  ) p
(for) K
( \(i = 0; i < pkt.length; i++\)) p n
(    pktbuf [i] = serialreceive \(\);) N
(#ifdef) K
( DEBUG) p n
(  puts \(") S
(; done\\n\\r) str
("\);) p n
(#endif) K n
() p n
(  ) S
(/* Store and return */) c n
(  pkt.data = pktbuf;) p n
(  ) S
(return) K
( &pkt;) p n
(}) N
(serial.c) (Page 4/4) (May 14, 98 23:32) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/serial.c) (42/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 43
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/******************************************) c n
(  state10.c) N
(  -- handles audio from M68k board -> Linux PC) N
() N
(  Compile with :) N
(gcc68s /home/sysd7/source/states/motorola/state10.c /home/sysd7/source/audio/aud) N
(io.c /home/sysd7/source/transport/motorola/polling.c /home/sysd7/source/low.leve) N
(l/motorola/board.c) N
(******************************************/) N
(#include) K
( <serial.h>) p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( <support.h>) p n
(#include) K
( <board.h>) p n
(#include) K
( <audio.h>) p n
() N
(/* the delay for the sample timer again  - see state4c.*/) c n
(#define) K
( SAMPLE_DELAY 39) p n
() N
(/*) c n
(  The main code for implementing state 10 of the IDP state machine.) N
(*/) N
(int) k
( state10\() p
(void) k
(\)) p n
({) N
(  ) S
(/* A Buffer in which to store incoming samples before they are compressed */) c n
(  ) p
(unsigned) k
( ) p
(char) k
( RecBuf[2];) p n
(  ) S
(/* Variable which indicates where the next sample will be stored. */) c n
(  ) p
(char) k
( BufPos=1;) p n
(  ) S
(/* timing variable to allow for the sample rate delay. */) c n
(  ) p
(int) k
( otime;) p n
(  ) S
(/* Holds the compressed data ready for sending on the next loop. */) c n
(  ) p
(unsigned) k
( ) p
(char) k
( Data_next;) p n
(  ) S
(/* This holds the return value of serialtransmit.  If it is non-zero,) c n
(     a state change has been requested. */) N
(  ) p
(int) k
( Control=0;) p n
() N
(  ) S
(/* start up the serial driver, initialise the hardware and the compressio) c n
(     software */) N
(  serialinit\(\);) p n
(  initAudio\(\);) N
(  initCompr\(\);) N
(  ) N
(  ) S
(/* Synch with PC... */) c n
(  serialtransmit\(') p
(A) str
('\);) p n
() N
(  ) S
(/* Initialise the old timer value to something big! */) c n
(  otime=1000;) p n
() N
(  ) S
(/* Set the timer going then wait for it to reset to acheive the correct) c n
(     sampling rate */) N
(  starttimer\(SAMPLE_DELAY\);) p n
(  ) S
(while) K
( \( otime > \(otime = gettimer\(\)\)\);) p n
(  ) S
(/* Grab the first sample */) c n
(  RecBuf[0] = \(getsample\(\)\);) p n
(  ) S
(while) K
( \(1\) {) p n
(    ) S
(/* wait for the timer to reset again. */) c n
(    ) p
(while) K
( \( otime > \(otime = gettimer\(\) > 0\) \);) p n
(    ) S
(/*grab a sample */) c n
(    RecBuf[v] = \(getsample\(\)\);) p n
(    ) S
(if) K
( \(BufPos\) {) p n
(      ) S
(/* If we have buffered two samples, then compress them ready for) c n
() S 8 T ( transmission on the next loop */) N
(      Data_next = compress\(RecBuf[0],RecBuf[1]\);) p n
(state10.c) (Page 1/2) (May 15, 98 0:49) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    } ) p
(else) K
( {) p n
(      ) S
(/* We have only buffered one sample so far, so we should send the) c n
() S 8 T ( previously compressed pair on this loop. */) N
(      Control = serialtransmit\(Data_next\);) p n
(      ) S
(/* Check for a state change being signalled */) c n
(      ) p
(if) K
( \(Control\) {) p n
() S 8 T () S
(/* If we are changing state, then shut down the serial and return. */) c n
() p 8 T (serialclose\(\);) N
() S 8 T () S
(return) K
( Control;) p n
(      }) N
(    }) N
(    ) S
(/* Alternate buffer position and loop. */) c n
(    BufPos=1-BufPos;) p n
(  }) N
(}) N
(state10.c) (Page 2/2) (May 15, 98 0:49) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/state10.c) (43/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 44
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Motorola state 2 - video) c n
(   ) N
(   This state performs 4 functions) N
() N
(   * it polls the video camera, it captures an image and uses a combination) N
(     of frame-difference and RLE encoding to compress the image before ) N
(     sending it via serial to the Linux client machine;) N
() N
(   * it polls the Dallas Ring to detect whether a ring is present in the) N
(     detector;) N
() N
(   * it checks for a signal from the client;) N
() N
(   * it polls the buzzer \(linked to the keypad\).) N
() N
(   Transitions) N
(  ) N
(   The following states can be entered from state 2:) N
() N
(   * state 1 --- a signal is received from the client instructing the) N
(     board to enter the initialisation state;) N
() N
(   * state 3 --- the buzzer is pressed;) N
() N
(   * state 5 --- a Dallas ring is detected.) N
() N
(   Otherwise state 2 will loop.) N
() N
(*/) N
() p n
(#include) K
( <motorola.video.h>) p n
(#include) K
( <serial.h>) p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( <quickcam.h>) p n
(#include) K
( <support.h>) p n
(#include) K
( <control.h>) p n
(#include) K
( <board.h>) p n
(#include) K
( <data.h>) p n
() N
(#define) K
( frameBufferSz 19200) p n
() N
(/* Refer to buffers defined in video/motorola/video.c */) c n
() p n
(extern) K
( ) p
(unsigned) k
( ) p
(char) k
( in[2][frameBufferSz];) p n
(extern) K
( ) p
(unsigned) k
( ) p
(char) k
( diff[frameBufferSz];) p n
(extern) K
( ) p
(unsigned) k
( ) p
(char) k
( compressed[frameBufferSz+1];) p n
() N
(/*) c n
(  This function will grab a frame but will abort the grab if it detects) N
(  that the buzzer is pressed or a dallas ring is present returning) N
(  the state to change to.  0 is returned if the grab completes.) N
( */) N
() p n
(int) k
( grabframe\() p
(char) k
( *buffer\)) p n
({) N
(  ) S
(int) k
( x, ret=0;) p n
(  ) S
(for) K
(\(x=0;x<20;x++\)) p n
(    {) N
(      QC_grabdata\(buffer+\(x*\(19200/20\)\),19200/20\);) N
(      ) S
(if) K
( \(checkkeypad\(\)\)) p n
() S 8 T () S
(if) K
(\(getkeypad\(\)==KP_DOORBELL\)) p n
() S 8 T (  {) N
(state2.c) (Page 1/3) (May 14, 98 23:24) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T (    ret=3;) N
() S 8 T (    ) S
(break) K
(;) p n
() S 8 T (  }) N
(      ) S
(if) K
( \(checkring\(\)\)) p n
() S 8 T ({) N
() S 8 T (  ret=5;) N
() S 8 T (  ) S
(break) K
(;) p n
() S 8 T (}) N
(    }) N
(  ) S
(return) K
( ret;) p n
(}) N
() N
() N
(/* Makes a noise and informs the PC that the doorbell has been pressed */) c n
() p n
(void) k
( informdoorbell \() p
(void) k
(\)) p n
({) N
(  packet pkt;) N
(  ) S
(char) k
( buzzer_pressed=BUZZER_PRESSED;) p n
() N
(  ) S
(/* Make a noise */) c n
(  starttimer\(40000\);) p n
(  buzzerled\(BUZZER\);) N
(  ) S
(while) K
(\(gettimer\(\)>10000\);) p n
(  buzzerled\(ALLOFF\);) N
(  stoptimer\(\);) N
() N
(  ) S
(/* Send packet */) c n
(  pkt.datatype=CONTROL;) p n
(  pkt.data=&\(buzzer_pressed\);) N
(  pkt.length=1;) N
(  senddata\(&pkt\);) N
(}) N
() N
(int) k
( state2 \() p
(void) k
(\)) p n
({) N
(  packet pkt;) N
(  ) S
(int) k
( errno, current=0, last=1, csz, x, y, *a, *b, *c,doorbell=0, ns;) p n
(  ) S
(/* Set retransmit flag to 1 for first transmission */) c n
(  ) p
(int) k
( retransmitFlag=1, changeState=0;) p n
(  ) S
(/* Init Camera */) c n
(  QC_init \(\);) p n
(  ) S
(while) K
(\(changeState==0\)) p n
(    {) N
(      ) S
(/* Check doorbell */) c n
(      ) p
(if) K
( \(checkkeypad\(\)\)) p n
() S 8 T () S
(if) K
( \(getkeypad\(\)==KP_DOORBELL\)) p n
() S 8 T (  {) N
() S 8 T (    informdoorbell \(\);) N
() S 8 T (    ) S
(return) K
( 3;) p n
() S 8 T (  }) N
() N
(      ) S
(/* Check Dallas Ring */) c n
(      ) p
(if) K
( \(checkring\(\)\)) p n
() S 8 T () S
(return) K
( 5;) p n
() N
(      ) S
(/* Test for retransmit flag */) c n
(      ) p
(if) K
(\(retransmitFlag==1\)) p n
() S 8 T ({    ) N
() S 8 T (  ) S
(/* Reset last frame so that when it is XORd a full picture is) c n
() S 8 T (     transmitted */) N
() p 8 T (      ) S
(for) K
(\(x=0;x<frameBufferSz;x++\)) p n
(state2.c) (Page 2/3) (May 14, 98 23:24) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/state2.c) (44/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3,1) 45
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T () S 16 T ({) N
() S 8 T () S 16 T (  in[last][x]=0;) N
() S 8 T () S 16 T (}) N
() S 8 T (}) N
() N
(      ) S
(/* Attempt to grab a frame */) c n
() p n
(      ) S
(if) K
( \(\(changeState = grabframe \(in[current]\)\) == 0\)) p n
() S 8 T ({) N
() S 8 T (  ) S
(/* Correction and smoothing */) c n
() p 8 T (  ) S
(for) K
(\(x=0;x<frameBufferSz;x++\)) p n
() S 8 T (    {) N
() S 8 T (      ) S
(if) K
( \(in[current][x] != 0\)) p n
() S 8 T () S 16 T (in[current][x]=16-in[current][x];) N
() S 8 T (    }) N
() N
() N
() S 8 T (  ) S
(/* XOR frame with previous to obtain difference) c n
() S 8 T (     Here I exploit the fact that the 68040 is 32 bit) N
() S 8 T (     so by treating the bytes as ints I can XOR) N
() S 8 T (     4 bytes at a time.... clever huh?) N
() S 8 T (  */) N
() p 8 T (  a=\() S
(int) k
( *\) in[current];) p n
() S 8 T (  b=\() S
(int) k
( *\) in[last];) p n
() S 8 T (  c=\() S
(int) k
( *\) diff;) p n
() S 8 T (  ) S
(for) K
( \(x = 0; x < \(frameBufferSz / 4\); x++\)) p n
() S 8 T (    c[x] = a[x] ^ b[x];) N
() N
() S 8 T (  ) S
(/* Use RLE to compress the difference ) c n
() S 8 T (     \(We increment compressed by 1 to make room for) N
() S 8 T (     a control byte\) */) N
() p 8 T (  csz=RLEencode\(diff,frameBufferSz,compressed+1\);) N
() N
() S 8 T (  ) S
(/* Tell the receiver whether this is the first frame in) c n
() S 8 T (     a sequence \(compressed[0]=1\) or not \(compressed[0]=0\) */) N
() p 8 T (  compressed[0]=retransmitFlag;) N
() S 8 T (  retransmitFlag=0;) N
() S 8 T (  ) S
(/* Construct Packet */) c n
() p n
() S 8 T (  pkt.datatype=VIDEO;) N
() S 8 T (  pkt.length=csz/8+2;) N
() S 8 T (  pkt.data=compressed;) N
() S 8 T (  ) N
() S 8 T (  ) S
(/* Place it in serial Queue and check for change of state) c n
() S 8 T (     instruction from client */) N
() p n
() S 8 T (  ns=senddata\(&pkt\);) N
() S 8 T (  ) S
(if) K
(\(ns > 0\)) p n
() S 8 T (    changeState=ns;) N
() S 8 T (  ) N
() S 8 T (  ) S
(/* Reverse what is current and what is previous */) c n
() p 8 T (  current=1-current;) N
() S 8 T (  last=1-last;) N
() S 8 T (}) N
(    };) N
(  ) S
(if) K
( \(changeState == 3\)) p n
(    informdoorbell \(\);) N
(  ) S
(return) K
( changeState;) p n
(}) N
(state2.c) (Page 3/3) (May 14, 98 23:24) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Motorola state 3 - Ian Clarke) c n
() N
(   Functionality as State 2 but without iButton and Buzzer) N
(   detection.  Times out after 10 video transmissions and returns) N
(   to State 2) N
(*/) N
() p n
(#include) K
( <motorola.video.h>) p n
(#include) K
( <serial.h>) p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( <quickcam.h>) p n
(#include) K
( <support.h>) p n
(#include) K
( <control.h>) p n
(#include) K
( <board.h>) p n
(#include) K
( <data.h>) p n
() N
(#define) K
( frameBufferSz 19200) p n
() N
(/* Refer to buffers defined in video/motorola/video.c */) c n
() p n
(extern) K
( ) p
(unsigned) k
( ) p
(char) k
( in[2][frameBufferSz];) p n
(extern) K
( ) p
(unsigned) k
( ) p
(char) k
( diff[frameBufferSz];) p n
(extern) K
( ) p
(unsigned) k
( ) p
(char) k
( compressed[frameBufferSz+1];) p n
() N
(int) k
( state3 \() p
(void) k
(\)) p n
({) N
(  packet pkt;) N
(  ) S
(int) k
( errno, current=0, last=1, csz, x, y, *a, *b, *c,doorbell=0, ns;) p n
(  ) S
(int) k
( timeout=10;) p n
() N
(  ) S
(/* Set retransmit flag to 1 for first transmission */) c n
(  ) p
(int) k
( retransmitFlag=1, changeState=0;) p n
() N
(  ) S
(/* Reinit Camera */) c n
() p n
(  QC_init\(\);) N
() N
(  ) S
(/* Inform client that buzzer has been pressed */) c n
(  ) p n
(  ) S
(while) K
(\(\(changeState==0\)&&\(timeout!=0\)\)) p n
(    {) N
(      timeout--;) N
(      ) S
(/* Test for retransmit flag */) c n
(      ) p
(if) K
(\(retransmitFlag==1\)) p n
() S 8 T ({) N
() S 8 T (  ) S
(/* Reset last frame so that when it is XORd a full picture is) c n
() S 8 T (     transmitted */) N
() p 8 T (      ) S
(for) K
(\(x=0;x<frameBufferSz;x++\)) p n
() S 8 T () S 16 T ({) N
() S 8 T () S 16 T (  in[last][x]=0;) N
() S 8 T () S 16 T (}) N
() S 8 T (}) N
() N
(      ) S
(/* Attempt to grab a frame */) c n
(      ) p
(if) K
( \(\(errno = QC_grabframe \(in[current]\)\) == QC_SUCCESS\)) p n
() S 8 T ({) N
() S 8 T (  ) S
(/* Correction and smoothing */) c n
() p 8 T (  ) S
(for) K
(\(x=0;x<frameBufferSz;x++\)) p n
() S 8 T (    {) N
() S 8 T (      ) S
(if) K
( \(in[current][x] != 0\)) p n
() S 8 T () S 16 T (in[current][x]=16-in[current][x];) N
() S 8 T (    }) N
(state3.c) (Page 1/2) (May 14, 98 23:24) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/state2.c, motorola/state3.c) (45/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2,1) 46
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() S 8 T (  ) S
(/* XOR frame with previous to obtain difference) c n
() S 8 T (     Here I exploit the fact that the 68040 is 32 bit) N
() S 8 T (     so by treating the bytes as ints I can XOR) N
() S 8 T (     4 bytes at a time.... clever huh?) N
() S 8 T (  */) N
() p 8 T (  a=\() S
(int) k
( *\) in[current];) p n
() S 8 T (  b=\() S
(int) k
( *\) in[last];) p n
() S 8 T (  c=\() S
(int) k
( *\) diff;) p n
() S 8 T (  ) S
(for) K
( \(x = 0; x < \(frameBufferSz / 4\); x++\)) p n
() S 8 T (    c[x] = a[x] ^ b[x];) N
() N
() S 8 T (  ) S
(/* Use RLE to compress the difference ) c n
() S 8 T (     \(We increment compressed by 1 to make room for) N
() S 8 T (     a control byte\) */) N
() p 8 T (  csz=RLEencode\(diff,frameBufferSz,compressed+1\);) N
() S 8 T (  ) S
(/* Tell the receiver whether this is the first frame in) c n
() S 8 T (     a sequence \(compressed[0]=1\) or not \(compressed[0]=0\) */) N
() p 8 T (  compressed[0]=retransmitFlag;) N
() S 8 T (  retransmitFlag=0;) N
() S 8 T (  ) S
(/* Construct Packet */) c n
() p n
() S 8 T (  pkt.datatype=VIDEO;) N
() S 8 T (  pkt.length=csz/8+2;) N
() S 8 T (  pkt.data=compressed;) N
() S 8 T (  ) N
() S 8 T (  ) S
(/* Place it in serial Queue and check for change of state) c n
() S 8 T (     instruction from client */) N
() p n
() S 8 T (  ns=senddata\(&pkt\);) N
() S 8 T (  ) S
(if) K
(\(ns > 0\)) p n
() S 8 T (    {) N
() S 8 T (      changeState=ns;) N
() S 8 T (    }) N
() S 8 T (  ) S
(/* Reverse what is current and what is previous */) c n
() p 8 T (  current=1-current;) N
() S 8 T (  last=1-last;) N
() S 8 T (}) N
(      ) S
(else) K n
() p 8 T ({) N
() S 8 T (  ) S
(/* Handle Failed Framegrab */) c n
() p 8 T (  ) S
(switch) K
( \(errno\)) p n
() S 8 T (    {) N
() S 8 T (    ) S
(case ) K
(QC_BAD_RESPONSE) l
(:) p n
() S 8 T (      puts \(") S
(Framegrab: Bad response from camera\\n\\r) str
("\);) p n
() S 8 T (      ) S
(break) K
(;) p n
() S 8 T (    ) S
(case ) K
(QC_TIMEOUT) l
(:) p n
() S 8 T (      puts \(") S
(Framegrab: Camera timed out\\n\\r) str
("\);) p n
() S 8 T (      ) S
(break) K
(;) p n
() S 8 T (    }) N
() S 8 T (}) N
(    };) N
(  ) S
(if) K
(\(timeout==0\)) p n
(    changeState=2;) N
(  ) S
(return) K
( changeState;) p n
(}) N
(state3.c) (Page 2/2) (May 14, 98 23:24) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* State 4 */) c n
(#include) K
( <serial.h>) p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( <support.h>) p n
(#include) K
( <board.h>) p n
(#include) K
( <audio.h>) p n
() N
(/***************************************************) c n
(  state4.c) N
(  -- Part of the motorola state machine. Handles audio ) N
(     from Linux PC -> M68k board.) N
() N
(  Compile with :) N
(gcc68s /home/sysd7/source/states/motorola/state4.c /home/sysd7/source/audio/audi) N
(o.c /home/sysd7/source/transport/motorola/polling.c /home/sysd7/source/low.level) N
(/motorola/board.c) N
() N
(***************************************************/) N
(/*) N
(  This is the value for the 68230's count register which controls the) N
(  timing of the audio.  i.e. it syncs it to roughly 8 KHz. ) N
(*/) N
(#define) K
( SAMPLE_DELAY 39) p n
() N
(/*) c n
(  This is the structure that represents the 68230's registers.  It is ) N
(  memory mapped to 0x05000000.) N
(*/) N
(volatile) K
( ) p
(struct) k
( mc68230fm * tpit = \() p
(void) k
( *\)0x05000000;) p n
() N
() N
(/* ) c n
(   Routine to initialise the audio hardware on the motorola's bus.) N
(*/) N
(void) k
( initAudio\() p
(void) k
(\)) p n
({) N
(  ) S
(/*) c n
(    Set up the counter preload registers cp?) N
(  */) N
(  tpit->cph=0x0;) p n
(  ) N
(  tpit->cpm=0x0;) N
() N
(  tpit->cpl=0x10;) N
(  ) S
(/*Start the timer going */) c n
(  tpit->tcr=0x43;) p n
(  ) N
(  ) S
(/* Set up data register A for our use. */) c n
(  tpit->ddra=0xE0;) p n
() N
(  tpit->dra=0xE0;) N
(}) N
() N
() N
(/*) c n
(  The main code for state 4 of the IDP state machine.) N
(*/) N
(int) k
( state4\() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( otimer=10000000;) p n
() N
(  ) S
(/* PlayBuf[]  -  incoming data is decompressed into this array and then) c n
(state4.c) (Page 1/3) (May 15, 98 0:29) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/state3.c, motorola/state4.c) (46/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (2-3) 47
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(     played. */) c n
(  ) p
(unsigned) k
( ) p
(char) k
( PlayBuf[2];) p n
() N
(  ) S
(/* Holds the position of the next sample to be played.  When this is 0,) c n
(     the routine will attempt to read a byte from the serial port and) N
(     decompress it into PlayBuf.*/) N
(  ) p
(char) k
( BufPos=0;) p n
() N
(  ) S
(/* Serial data is read into this byte before being decoded. */) c n
(  ) p
(unsigned) k
( ) p
(char) k
( Data_next;) p n
() N
() N
(  ) S
(/* Initialise the board settings, the serial driver and the decompression) c n
(     routines.*/) N
(  initAudio\(\);) p n
(  serialinit\(\);) N
(  initDecompr\(\);) N
(  ) N
(  ) S
(/* Set the direction bits of data register A to 11100000. */) c n
(  tpit->ddra=0xE0;) p n
(  ) S
(/* Set data register A to the same thing. */) c n
(  tpit->dra=0xE0;) p n
() N
(  ) S
(/* Wait for a byte from PC to indicate start up. */) c n
(  serialreceive\(\);) p n
(  ) N
(  ) S
(/* Initialise the sample timer */) c n
(  starttimer\(SAMPLE_DELAY\);) p n
(  ) S
(/* Get the first data byte from the PC.) c n
(     This has to be here in order to even out the processing requirements.) N
(  */) N
(  Data_next = serialreceive\(\);) p n
(  ) S
(while) K
( \(1\) {) p n
(    ) S
(if) K
( \(BufPos\) {) p n
(      ) S
(/* If we are about to play the second sample in the buffer, fetch the) c n
() S 8 T ( next byte of data ready for decompression */) N
(      Data_next = serialreceive\(\);) p n
(      ) S
(if) K
( \(Data_next == 0xFF\) {) p n
() S 8 T () S
(/* This could be the PC trying to indicate a state change, so get) c n
() S 8 T (   the next item of data to see what to do. */) N
() p 8 T (Data_next = serialreceive\(\);) N
() S 8 T () S
(if) K
( \(Data_next != 0xFF\) {) p n
() S 8 T (  ) S
(/* The data wasn't another FF, so quit and return the state to ) c n
() S 8 T (     change into. */) N
() p 8 T (  ) S
(return) K
( \() p
(int) k
(\) Data_next;) p n
() S 8 T (}) N
(      }) N
(    } ) S
(else) K
( {) p n
(      ) S
(/* If we are about to have to play the first sample in the buffer,) c n
() S 8 T ( we had better decompress the samples into it so that they can be) N
() S 8 T ( played. */) N
(      decompress\(Data_next, PlayBuf\);) p n
(    }) N
(    ) S
(/* Wait for the audio timer...*/) c n
(    ) p
(while) K
( \( otimer > \(otimer=gettimer\(\)\)\);) p n
(    ) S
(/* Play the next sample throught the DAC. */) c n
(    setsample \(PlayBuf[BufPos]\);) p n
(    ) S
(/* Change to the next sample in the buffer and loop. */) c n
(    BufPos = 1 - BufPos;) p n
(  }) N
() N
(}) N
(state4.c) (Page 2/3) (May 15, 98 0:29) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
() N
(state4.c) (Page 3/3) (May 15, 98 0:29) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/state4.c) (47/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1,1) 48
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Motorola state 7 - refuse door entry) c n
(   Stephen Kitt) N
(*/) N
() p n
(#include) K
( <board.h>) p n
() N
(int) k
( state7 \() p
(void) k
(\)) p n
({) N
(  ) S
(int) k
( i;) p n
() N
(  ) S
(/* Flash the red LED on and off five times */) c n
(  ) p
(for) K
( \(i = 0; i < 5; i++\)) p n
(    {) N
(      buzzerled \(LEDRED\);) N
(      starttimer \(210000\);) N
(      ) S
(while) K
( \(gettimer \(\) > 110000\);) p n
(      buzzerled \(ALLOFF\);) N
(      ) S
(while) K
( \(gettimer \(\) > 10000\);) p n
(      stoptimer \(\);) N
(    }) N
(  ) S
(return) K
( 2;) p n
(}) N
(state7.c) (Page 1/1) (May 14, 98 23:22) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Motorola state 8 - open the door) c n
(   Stephen Kitt) N
(*/) N
() p n
(#include) K
( <board.h>) p n
() N
(int) k
( state8 \() p
(void) k
(\)) p n
({) N
(  ) S
(/* Open the door and wait for it to be opened or 15 seconds to) c n
(     elapse before closing it again */) N
(  starttimer \(3010000\);) p n
(  buzzerled \(LEDGREEN\);) N
(  ) S
(while) K
( \(gettimer \(\) > 10000 && getdoorstatus \(\)\);) p n
(  stoptimer \(\);) N
(  buzzerled \(ALLOFF\);) N
(  ) S
(return) K
( 2;) p n
(}) N
(state8.c) (Page 1/1) (May 14, 98 23:23) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/state7.c, motorola/state8.c) (48/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 49
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/* Database User Validation functions ) c n
( * Edward Knowelden) N
( */) N
(/* Needs libsupport.a library for puts */) N
(/* Needs m_support.c for string functions */) N
() p n
(#include) K
( <database.h>) p n
() N
(extern) K
( local_db_item db_local_store[];) p n
(extern) K
( ) p
(int) k
( pin_pos;) p n
(extern) K
( ) p
(char) k
( uid_no[13];) p n
(extern) K
( ) p
(int) k
( got_uid;) p n
(extern) K
( ) p
(int) k
( pin;) p n
() N
() N
(/* Registers a digit from a keypress for a PIN.) c n
( * Returns TRUE if PIN is ready to validate, FALSE otherwise ) N
( */) N
(int) k
( send_keypad_digit\() p
(int) k
( digit\)) p n
({) N
(  ) S
(int) k
( pin_int, result;) p n
() N
(  ) S
(if) K
(\(got_uid\){) p n
(    pin = pin * 10 + digit;) N
(    pin_pos++;) N
(    ) S
(if) K
(\(pin_pos == PIN_SIZE\){) p n
(      ) S
(return) K
( TRUE;) p n
(    }) N
(  }) N
(  ) S
(return) K
( FALSE;) p n
(}) N
() N
(/* Compares the uid stored in global variable with those in) c n
( * database. Then compares stored PIN with that from the database. ) N
( */) N
(int) k
( validate_user\() p
(char) k
( *uid, ) p
(int) k
( pin\)) p n
({) N
(  ) S
(int) k
( count = 0,i;) p n
(  ) S
(/* simple search for uid */) c n
(  ) p
(while) K
(\(strcomp\(uid,db_local_store[count].uid\) != 0\) {) p n
(    ) S
(if) K
(\(db_local_store[count].uid[0] == ') p
(X) str
('\) ) p
(break) K
(;) p n
(    ) S
(else) K
( count++;) p n
(  }) N
(  ) S
(if) K
(\(db_local_store[count].uid[0] == ') p
(X) str
('\) {) p n
(    ) S
(return) K
( FALSE;) p n
(  }) N
() N
(  ) S
(if) K
( \(pin == db_local_store [count].pin\)) p n
(    ) S
(return) K
( 1;) p n
(  ) S
(else) K
( ) p
(return) K
( 0;) p n
(}) N
() N
(/* converts a 6 digit string from dallas ring into 12-digit hex serial) c n
(   number */) N
(void) k
( conv_hchar \() p
(unsigned) k
( ) p
(long) k
( number, ) p
(char) k
( *buffer\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(long) k
( magnitude;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( digit;) p n
(  ) S
(int) k
( digits = 2;) p n
(  ) S
(int) k
( base =16;) p n
(  ) S
(int) k
( i=0;) p n
() N
(validate.c) (Page 1/2) (May 15, 98 5:12) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  magnitude = 1;) p n
(  ) S
(while) K
( \(digits > 1\)) p n
(    {) N
(      magnitude *= base;) N
(      digits--;) N
(    };) N
(  ) S
(while) K
( \(magnitude > 0\){) p n
(    digit = number / magnitude;) N
(    ) S
(if) K
( \(digit < 10\)) p n
(      buffer[i] = \(') S
(0) str
(' + digit\);) p n
(    ) S
(else) K n
(      buffer[i] = \(') p
(A) str
(' - 10 + digit\);) p n
(    number %= magnitude;) N
(    magnitude /= base;) N
(    i++;) N
(    buffer[i] = ') S
(\\0) str
(';) p n
(  }) N
(}) N
() N
(validate.c) (Page 2/2) (May 15, 98 5:12) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/validate.c) (49/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (1-2) 50
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(/*) c n
(  Motorola Video Compression and Transmission Code) N
(  $Id: video.c,v 1.10 1998/05/07 14:06:28 iic Exp iic $) N
(  $Log: video.c,v $) N
(  Revision 1.10  1998/05/07 14:06:28  iic) N
(  Removed CRC checking, seemed unnescessary and over fussy) N
() N
(  Revision 1.9  1998/04/30 10:04:50  iic) N
(  Fixed incorrectly used Enum) N
() N
(  Revision 1.8  1998/04/29 13:42:01  iic) N
(  Used data.VIDEO definition in data.h) N
() N
(  Revision 1.7  1998/04/28 14:59:44  iic) N
(  Minor changes) N
() N
(  Revision 1.6  1998/04/28 12:34:23  iic) N
(  Fixed some bugs found during testing, but still not tested with) N
(  serial code.) N
() N
(  Revision 1.5  1998/04/27 16:25:50  iic) N
(  Completed transmission code.  Now it *should* work but can't test) N
(  until serial code is up and running) N
() N
(  Revision 1.4  1998/04/27 15:18:12  iic) N
(  Made XOR code about 4 times faster by treating char array as an int array) N
() N
(  Revision 1.3  1998/04/27 15:05:17  iic) N
(  Fixed some minor bugs so that it now syntax checks) N
() N
(  Revision 1.2  1998/04/27 14:41:38  iic) N
(  Created runVideo\(\) function, init camera, XOR and compress, but not) N
(  yet transmission) N
() N
(*/) N
() p n
(#include) K
( <motorola.video.h>) p n
(#include) K
( <serial.h>) p n
(#include) K
( <m68kboard.h>) p n
(#include) K
( <quickcam.h>) p n
(#include) K
( <support.h>) p n
(#include) K
( <data.h>) p n
() N
(/*) c n
(  Some bit manipulation utility functions, designed by Ian Clarke) N
(  \(iic@dcs.ed.ac.uk\), this implementation due to Stephen Kitt) N
(  \(skk@dcs.ed.ac.uk\).) N
(*/) N
() p n
(void) k
( setbit \() p
(unsigned) k
( ) p
(char) k
( * ptr, ) p
(unsigned) k
( ) p
(long) k
( off, ) p
(int) k
( val\)) p n
({) N
(  ) S
(unsigned) k
( ) p
(int) k
( idx, bit;) p n
(  idx = \() S
(unsigned) k
( ) p
(int) k
(\) \(off / 8\);) p n
(  bit = 7 - \(\() S
(unsigned) k
( ) p
(int) k
(\) \(off % 8\)\);) p n
(  ) S
(if) K
( \(val\)) p n
(    ptr [idx] |= 1 << bit;) N
(  ) S
(else) K n
(    ptr [idx] &= ~\(1 << bit\);) p n
(}) N
() N
(unsigned) k
( ) p
(char) k
( bitset[] = { 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F,) p n
() S 8 T () S 16 T () S 24 T (   0x7F, 0xFF };) N
(video.c) (Page 1/3) (May 15, 98 9:13) title
border
/v 1 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(/* Maximum bits set: 8 */) c n
(/* This works by splitting the changes over at most two bytes, zeroing) N
(   out the changed sections, and OR'ing the changes.) N
(   For example, say we have the following two bytes:) N
(           01100000 00000000) N
(   and we want to store the value 011111 at offset 3; this splits into) N
(   two bytes, 00001111 and 1000000. We zero out the changed area) N
(   \(nothing changes\) and OR to get:) N
(           01101111 10000000) N
(   which is the desired result. */) N
(void) k
( setval \() p
(unsigned) k
( ) p
(char) k
( * ptr, ) p
(unsigned) k
( ) p
(long) k
( off, ) p
(int) k
( val, ) p
(int) k n
() p 8 T (     bits\)) N
({) N
(  ) S
(int) k
( bit;) p n
(  ) S
(unsigned) k
( ) p
(char) k
( * realptr;) p n
(  ) S
(int) k
( coff;) p n
(  realptr = ptr + \(off / 8\);) N
(  bit = off % 8;) N
(  coff = bits + bit - 8;) N
(  ) S
(if) K
( \(coff > 0\)) p n
(    {) N
(      realptr [0] &= ~\(bitset [bits] >> coff\);) N
(      realptr [1] &= ~\(bitset [bits] << \(8 - coff\)\);) N
(      realptr [0] |= val >> coff;) N
(      realptr [1] |= val << \(8 - coff\);) N
(    }) N
(  ) S
(else) K n
(    {) p n
(      coff = -coff;) N
(      *realptr &= ~\(bitset [bits] << coff\);) N
(      *realptr |= val << coff;) N
(    }) N
(}) N
() N
(/*) c n
(  `src' is a pointer to an array of unsigned chars of length sLen) N
(   where only the 4 least significant bits are to be compressed.) N
(  `dst' is a pointer to a buffer which should be of at least) N
(   size \(sLen*8\)/5+1.) N
(  This buffer will be filled with a RLE encoded version of src) N
(  and the function will return the compressed length in bits.) N
(                                                        ^^^^) N
( */) N
() p n
(int) k
( RLEencode\() p
(unsigned) k
( ) p
(char) k
( * src, ) p
(int) k
( sLen, ) p
(unsigned) k
( ) p
(char) k
( * dst\)) p n
({) N
(  ) S
(int) k
( sPtr, dPtr=0 , count=1;) p n
(  ) S
(for) K
(\(sPtr=1;sPtr<sLen;sPtr++\)) p n
(    {) N
(      ) S
(if) K
( \(\(src[sPtr]==src[sPtr-1]\)&&\(count!=33\)\)) p n
() S 8 T ({) N
() S 8 T (  count++;) N
() S 8 T (}) N
(      ) S
(else) K n
() p 8 T ({) N
() S 8 T (  ) S
(if) K
( \(count==1\)) p n
() S 8 T (    {) N
() S 8 T (      setbit\(dst,dPtr,0\); dPtr++;) N
() S 8 T (      setval\(dst,dPtr,src[sPtr-1],4\);) N
() S 8 T (      dPtr+=4;) N
() S 8 T (    }) N
(video.c) (Page 2/3) (May 15, 98 9:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/video.c) (50/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage
%%Page: (3) 51
%%BeginPageSetup
/pagesave save def
sh 0 translate
90 rotate
%%EndPageSetup
latin1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.362408 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T (  ) S
(else) K n
() p 8 T (    {) N
() S 8 T (      setbit\(dst,dPtr,1\); dPtr++;) N
() S 8 T (      setval\(dst,dPtr,src[sPtr-1],4\);) N
() S 8 T (      dPtr+=4;) N
() S 8 T (      setval\(dst,dPtr,count-2,5\);) N
() S 8 T (      dPtr+=5;) N
() S 8 T (    }) N
() S 8 T (  count=1;) N
() S 8 T (}) N
(    }) N
(  ) S
(if) K
( \(count==1\)) p n
(    {) N
(      setbit\(dst,dPtr,0\); dPtr++;) N
(      setval\(dst,dPtr,src[sPtr-1],4\);) N
(      dPtr+=4;) N
(    }) N
(  ) S
(else) K n
(    {) p n
(      setbit\(dst,dPtr,1\); dPtr++;) N
(      setval\(dst,dPtr,src[sPtr-1],4\);) N
(      dPtr+=4;) N
(      setval\(dst,dPtr,count-2,5\);) N
(      dPtr+=5;) N
(    }) N
(  ) S
(return) K
( dPtr;) p n
(}) N
() N
(/* Define buffers */) c n
() p n
(#define) K
( frameBufferSz 19200) p n
() N
(unsigned) k
( ) p
(char) k
( in[2][frameBufferSz];) p n
(unsigned) k
( ) p
(char) k
( diff[frameBufferSz];) p n
(unsigned) k
( ) p
(char) k
( compressed[frameBufferSz+1];) p n
(video.c) (Page 3/3) (May 15, 98 9:13) title
border
% End of virtual page
grestore
(Printed by System Design 7) rhead
(motorola/video.c) (51/51) (Friday May 15, 98) footer
end % of latin1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
