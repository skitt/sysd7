#This file was created by <skk> Fri May 15 08:38:02 1998
#LyX 0.12 (C) 1995-1998 Matthias Ettrich and the LyX Team
\lyxformat 2.15
\textclass article
\language default
\inputencoding default
\fontscheme palatino
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage widemarginsa4
\use_geometry 0
\use_amsmath 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle headings

\layout Title

System Design Project
\newline 
Software Manual
\layout Author

System Design Group 7
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center 

\begin_inset Figure size 128 125
file ../../web/images/EUcrest-official-noborder.ps
flags 11

\end_inset 


\layout Standard
\pagebreak_top \pagebreak_bottom 

\begin_inset LatexCommand \tableofcontents

\end_inset 


\layout Section

Introduction
\layout Standard

This document describes the software in our door-entry system.
\layout Standard

The biggest issue in the software design, apart from building a working
 product, was modularity, so that different people could work on different
 sections of code reasonably independently.
 Therefore the software was split up thus:
\layout Itemize

low-level --- interaction with the hardware;
\layout Itemize

serial driver --- communications between the PC and Motorola board;
\layout Itemize

video --- compression and decompression of the video;
\layout Itemize

audio --- compression and decompression of the audio, using the Linux Open
 Sound System and the low-level code;
\layout Itemize

control --- storing and retrieving the user and configuration information;
\layout Itemize

GUI --- the user interface on the PC.
\layout Standard

The Motorola side of the software is integrated using a state-machine paradigm;
 the PC side uses a more traditional event-based GUI.
\layout Section

The modules
\layout Standard

All the modules apart from the low-level module supply functionality used
 across both systems.
 They form the basis for the two pieces of software running on the PC and
 the Motorola.
\layout Subsection

Low-level
\layout Standard

This module is only required on the Motorola side, since the PC low-level
 functionality is controlled by its operating system (Linux on the prototype).
\layout Subsubsection

Evolution
\layout Standard

The low-level code was developed as the hardware progressed; this allowed
 us to test the hardware very soon after its implementation and thus catch
 bugs sooner rather than later.
\layout Subsubsection

Programmer interface
\layout Standard

The function definitions are contained in 
\family typewriter 
board.c
\family default 
; the corresponding header file is 
\family typewriter 
board.h
\family default 
.
\layout Paragraph

Initialisation
\layout Standard


\family typewriter 
int boardinit (void)
\family default 
 initialises the secondary board; it disables the MC\SpecialChar \-
68230's timer and sets
 its ports to inputs and outputs as required.
\layout Paragraph

Timer functions
\layout Standard

The timer functions use the secondary MC68230's built-in timer; this can
 be loaded with a given value, up to 16,777,215; this value then decrements
 every 3.2
\begin_inset Formula \( \mu  \)
\end_inset 

s (
\emph on 
i.e.

\emph default 
 every 32 cycles, at 10MHz), and loops back to the preloaded value when
 it reaches 0.
 Note that this timer also drives the secondary board's ADC, so care should
 be taken when using the two simultaneously (see the audio code).
\layout Standard


\family typewriter 
void starttimer (int)
\family default 
 disables the timer, loads the secondary MC68230's timer preload and re-activate
s the timer (to ensure it starts from the preloaded value).
\layout Standard


\family typewriter 
int stoptimer (void)
\family default 
 disables the timer and returns its current value.
\layout Standard


\family typewriter 
int gettimer (void)
\family default 
 returns the current timer value.
\layout Paragraph

Keypad and doorbell functions
\layout Standard

These are combined since the doorbell is wired to the keypad encoder in
 hardware.
\layout Standard


\family typewriter 
int checkkeypad (void)
\family default 
 returns 1 if a key is currently pressed down, 0 otherwise.
\layout Standard


\family typewriter 
int getkeypad (void)
\family default 
 waits for a key to be pressed then released and returns its code, which
 can be an integer from 0 to 9, corresponding to the respective keys, or
 
\family typewriter 
KP_HASH
\family default 
, 
\family typewriter 
KP_STAR
\family default 
, 
\family typewriter 
KP_DOORBELL
\family default 
 and 
\family typewriter 
KP_UNDEF
\family default 
 for, respectively, the `#' and `*' keys, the doorbell, and an undefined
 key (which should never happen unless something else is wired into the
 encoder).
\layout Paragraph

Dallas Semiconductor iButton functions
\layout Standard


\family typewriter 
int checkring (void)
\family default 
 returns 1 if an iButton is present in the holder, and 0 otherwise; it also
 has the side-effect of resetting the iButton and should be called before
 
\family typewriter 
getringinfo
\family default 
.
\layout Standard


\family typewriter 
ringinfo getringinfo (void)
\family default 
 returns a structure containing the iButton's information.
 The structure is defined as follows:
\layout LyX-Code

typedef struct
\layout LyX-Code

{
\layout LyX-Code


\protected_separator 
 unsigned char product;
\layout LyX-Code


\protected_separator 
 unsigned char id [6];
\layout LyX-Code


\protected_separator 
 unsigned char crc;
\layout LyX-Code

} ringinfo;
\layout Standard

The function verifies the CRC itself and only returns when a valid key has
 been read.
\layout Paragraph

Door, buzzer and LED functions
\layout Standard

These are linked in hardware; the red LED and buzzer can operate independently,
 albeit not simultaneously, but the green LED opens the door.
\layout Standard


\family typewriter 
int getdoorstatus (void)
\family default 
 returns 1 if the door is currently closed, 0 if it's open.
\layout Standard


\family typewriter 
int opendoor (void)
\family default 
 opens the door.
\layout Standard


\family typewriter 
int closedoor (void)
\family default 
 closes the door.
\layout Standard


\family typewriter 
int buzzerled (int)
\family default 
 performs the given function on the buzzer, door and LEDs: 
\family typewriter 
ALLOFF 
\family default 
switches everything off, 
\family typewriter 
BUZZER
\family default 
 switches the buzzer on, 
\family typewriter 
LEDGREEN
\family default 
 switches the green LED on and opens the door, and 
\family typewriter 
LEDRED
\family default 
 switches the red LED on.
 Note again that only one of the three can be active at any one time; activating
 another element switches the others off.
\layout Standard


\family typewriter 
void leddisplay (unsigned char)
\family default 
 displays the given ASCII character (`0'--`9', space, or `a'--`z') on the
 seven-segment display on the IDP.
\layout Paragraph

Miscellaneous functions
\layout Standard


\family typewriter 
nop ()
\family default 
 is a C pre-processor macro which instructs the compiler to insert a no-operatio
n instruction.
\layout Subsubsection

Internals
\layout Standard

Hardware access is done entirely through memory-mapped registers.
 The secondary board's MC68230 is mapped to 
\family typewriter 
05000000
\family default 
 hex; the seven-segment LED display is mapped to 
\family typewriter 
00D00000
\family default 
 hex.
\layout Standard

The 230 uses registers, as described in its manual.
 On the secondary board, the 230's ports are mapped as follows:
\layout Itemize

channel A, bits 7--6: DAC control;
\layout Itemize

channel A, bit 5: iButton reader (input and output);
\layout Itemize

channel A, bit 4: keypad control (input);
\layout Itemize

channel A, bits 3--0: keypad data (input);
\layout Itemize

channel B: DAC and ADC data (input for ADC, output for DAC);
\layout Itemize

channel C, bit 6: door sensor (input);
\layout Itemize

channel C, bits 4--3: 230 timer input;
\layout Itemize

channel C, bits 1--0: buzzer and LEDs (output).
\layout Standard

The iButton reader uses a single wire, which is set high or low (1 or 0)
 on output for certain lengths of time then read to get the required information.
 Thus, to check for and reset an iButton, the wire is set to output, pulled
 low for 480 
\begin_inset Formula \( \mu  \)
\end_inset 

s, set to input and read for up to 960 
\begin_inset Formula \( \mu  \)
\end_inset 

s; if it returns high, then low, then high again, an iButton is present
 and has been reset; otherwise the wire returns high and stays there.
 Retrieving the iButton's information (product family code, user ID, and
 CRC) is done in a similar fashion; see Dallas' manual for more details.
\layout Standard

The keypad control is high if and only if a key is currently being pressed.
 To read the key, the code waits for the keypad control to go high (the
 key is pressed) then low again (the key is released); then the encoder's
 output can be read as the keypad data.
 The encoder is a 
\begin_inset Formula \( 4\times 4 \)
\end_inset 

 matrix, connected as follows (NC: not connected):
\layout Standard
\added_space_top 0.3cm \added_space_bottom 0.3cm \align center \LyXTable
multicol4
4 4 0 0 -1 -1 -1 -1
1 0 0 0
1 0 0 0
1 0 0 0
1 1 0 0
8 1 0 
8 1 0 
8 1 0 
8 1 1 
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0
0 8 1 0 0 0 0

1
\newline 
2
\newline 
3
\newline 
doorbell
\newline 
4
\newline 
5
\newline 
6
\newline 
NC
\newline 
7
\newline 
8
\newline 
9
\newline 
NC
\newline 
*
\newline 
0
\newline 
#
\newline 
NC
\layout Standard

The door sensor is high if the door is closed, low if it's open.
\layout Standard

The 230 timer input is used by the hardware to drive the ADC sampling rate;
 the actual sampling speed is controlled in software, using the 230's standard
 timer functions.
\layout Standard

The buzzer and LED controls are multiplexed, since they never need to be
 on simultaneously; thus 
\family typewriter 
11
\family default 
 (both lines high) switched everything off, 
\family typewriter 
00
\family default 
 switched the green LED on (and opens the door), 
\family typewriter 
01
\family default 
 switches the buzzer on, and 
\family typewriter 
10
\family default 
 switched the red LED on.
\layout Subsubsection

Future direction
\layout Standard

A number of the functions defined in 
\family typewriter 
board.h
\family default 
 haven't been implemented, because they weren't used in the final design.
 The non-volatile memory (NVRAM) functions in particular would be useful
 to store a master PIN or other semi-permanent information.
\layout Subsection

Serial
\layout Subsubsection

Evolution
\layout Standard

The original design of the serial sub-system was event-driven both on the
 Motorola and the PC; thus, the serial code was only active when the UART
 was ready for data, and the rest of the program could continue functioning
 while data transfers or receives were in progress.
\layout Standard

In the end though it was more effective to use polled serial for the Motorola
 side.
 The three portions of the system which exert the serial code most are the
 database download, the video transfers and the audio transfers.
 The database download can't proceed until the data has been fully received,
 so events are useless here.
 In theory, events would be very useful; for example, video transfers could
 then occur while the next frame is being grabbed from the camera.
 Unfortunately the design of the supplied Quickcam drivers would seem to
 prevent us from doing so, which makes it necessary to shut down an event-driver
 serial driver before using the camera; this results in a great loss of
 speed, since reinitialising the camera every time a frame is grabbed is
 very time consuming.
\layout Standard

The PC uses a mixture of polled and event-driven serial; writes from the
 PC to the Motorola are polled (
\emph on 
i.e.

\emph default 
 the PC waits until each byte has been sent, or at least buffered by the
 operating system), and reads are event-driven (
\emph on 
i.e.

\emph default 
 the operating system informs the program whenever data is available).
\layout Subsubsection

Programmer interface
\layout Standard

Unless specified, all functions return an 
\family typewriter 
int
\family default 
 which will be 0 for success and 
\begin_inset Formula \( -1 \)
\end_inset 

 for failure.
\layout Paragraph

Initialisation
\layout Standard

The 
\family typewriter 
int serialinit (void)
\family default 
 function is provided to initialise the serial subsystem.
 On the Motorola, it sets up the IDP's DUART (MC68681) for no parity, eight
 bits per character, one stop bit, 38400bps communications.
 On the PC, it initialises the input buffer, registers a 
\family typewriter 
SIGIO
\family default 
 handler, opens and sets up the second serial line (
\family typewriter 
/dev/ttyS1
\family default 
) with the same settings as used on the Motorola, and clears the packet
 handlers.
\layout Paragraph

Shutdown
\layout Standard

The 
\family typewriter 
int serialclose (void)
\family default 
 function shuts the serial subsystem down.
 On the Motorola, it doesn't do anything; on the PC, it waits for reception
 to cease, and closes the serial line.
\layout Paragraph

Transmission
\layout Standard

Two functions allow programs to transmit data.
\layout Standard

The simplest is 
\family typewriter 
int serialtransmit (unsigned char)
\family default 
; this transmits the character passed as argument, and waits for it to go.
 It will return 0 on success, 
\begin_inset Formula \( -1 \)
\end_inset 

 on failure, and a state number if a state-change request occurred during
 the transmission.
\layout Standard


\begin_inset LatexCommand \label{Packets}

\end_inset 

The other is 
\family typewriter 
int senddata (packet *)
\family default 
.
 This transmits a full packet, defined as follows:
\layout LyX-Code

typedef struct
\layout LyX-Code

{
\layout LyX-Code


\protected_separator 
 unsigned char datatype;
\layout LyX-Code


\protected_separator 
 unsigned int length;
\layout LyX-Code


\protected_separator 
 unsigned char * data;
\layout LyX-Code

} packet;
\layout Standard

The full packet is transmitted (or at least, buffered by the operating system)
 before 
\family typewriter 
senddata
\family default 
 returns.
 Again, senddata will return 0 on success, 
\begin_inset Formula \( -1 \)
\end_inset 

 on failure, and a state number if a state-change request occurred during
 the transmission.
\layout Standard

Note that packet datatypes 0, 1 and 2 are reserved for internal use.
 Other packets used by the system currently are 
\family typewriter 
VIDEO
\family default 
, 
\family typewriter 
AUDIO
\family default 
 and 
\family typewriter 
CONTROL
\family default 
; the latter is used to transmit state changes, database information and
 so on.
\layout Paragraph

Reception
\layout Standard

Again, there are two distinct ways of receiving data.
\layout Standard


\family typewriter 
int serialreceive (void)
\family default 
 waits for a character to arrive and returns it, or 
\begin_inset Formula \( -1 \)
\end_inset 

 if it timed out.
\layout Standard

On the Motorola, 
\family typewriter 
packet * receivepacket (void)
\family default 
 waits for a complete packet to arrive and returns a pointer to it; a copy
 of this should be made before the next call to 
\family typewriter 
receivepacket
\family default 
.
\layout Standard

On the PC, 
\family typewriter 
int registerhandler (unsigned char, packethandler)
\family default 
 and 
\family typewriter 
int unregisterhandler (unsigned char)
\family default 
 respectively register and unregister a handler function for packets of
 the given datatype.
 A 
\family typewriter 
packethandler
\family default 
 is defined as a pointer to a function taking a pointer to a 
\family typewriter 
packet
\family default 
 and returning 
\family typewriter 
void
\family default 
.
 The event-driven serial reception code on the PC then ensures the relevant
 packet handler is called, if any, whenever packets are enabled.
\layout Paragraph

Packet control
\layout Standard

Packets are enabled and disabled using the 
\family typewriter 
void enablepackets (void)
\family default 
 and 
\family typewriter 
void disablepackets (void)
\family default 
 functions respectively.
\layout Paragraph

State changes
\layout Standard

The serial module also handles the transmission of state change information
 from PC to the Motorola.
\layout Standard


\family typewriter 
void changestate (unsigned char)
\family default 
 causes the Motorola to switch to the given state.
\layout Subsubsection

Internals
\layout Standard

On the Motorola, the MC68681 UART is memory-mapped; programming is done
 entirely through its registers, and data transmission and reception wait
 for the UART's status register to indicate that it's ready.
\layout Standard

On the Linux, the standard 
\family typewriter 
tty
\family default 
 device is used; in this case, /dev/ttyS1.
 Transmission uses the write function.
 Reception is event-driven, using a SIGIO handler and a circular buffer;
 whenever data is received, the handler is called, and the data is read
 into the buffer.
 When enough data is available for a complete packet to be formed, the packet's
 data handler is called, then the data is discarded from the circular buffer.
\layout Standard

State changes are a fairly complex operation.
 The 
\family typewriter 
changestate
\family default 
 function pings the Motorola; the Motorola's 
\family typewriter 
serialtransmit
\family default 
 and 
\family typewriter 
senddata
\family default 
 functions will spot this, and store the fact that a ping acknowledgement
 is needed.
 Then as soon as it's safe to transmit a packet (
\emph on 
i.e.

\emph default 
 when the current packet is fully transmitted), the Motorola sends an acknowledg
ement packet to the PC and waits for the state number to come through.
 On reception, the PC's data handler (provided by the serial code) transmits
 the state number, and 
\family typewriter 
serialtransmit
\family default 
 or 
\family typewriter 
senddata
\family default 
 return it on the 
\emph on 
Motorola
\emph default 
...
 Some state changes are in fact performed manually by the code --- specifically,
 the initial synchronising operation (in the GUI's 
\family typewriter 
main
\family default 
 function) and the audio state changes.
\layout Subsection

Video
\layout Standard

The video software is responsible for capturing a frame from the video camera
 on the Motorola board, compressing it, transmitting it to the Linux machine
 via the serial module, decompressing it on the Linux box, and passing it
 on to the Graphical User Interface.
\layout Subsubsection

Evolution
\layout Standard

It was immediately recognized at the outset of this project that as each
 frame of video would be 19.2k in raw format, this would require over 4 seconds
 to transmit across the serial link to the Linux machine in addition to
 the time required to capture the frame.
 We decided that this would not be satisfactory and an image compression
 algorithm should be employed.
\layout Standard

We decided that a run-length encoding
\begin_float footnote 
\layout Standard

Run-length encoding is an algorithm for compressing data which consists
 of strings of the same character repeated several times.
 For example, rather than transmitting the string 
\begin_inset Quotes eld
\end_inset 

aaaaaaabbbbbbb
\begin_inset Quotes erd
\end_inset 

 which would require 14 bytes, an instruction to repeat `a' 7 times followed
 by `b' 7 times would only require about 4 bytes.
\end_float 
 algorithm would be most appropriate.
 We also decided to employ frame difference to further reduce the size of
 the compressed images.
 We would also be able to make use of the fact that pixel values were restricted
 to being between 0 and 15 inclusive.
\layout Standard

Our initial run length encoding algorithm operated at the byte level.
 The 4 most significant bits of each byte would specify how many times the
 pixel represented by 4 least significant bits of that byte was to be repeated.
 This proved unsatisfactory as individual pixels which were surrounded by
 pixels of different lengths required one byte to encode.
 We therefore decided upon the 5 bit block encoding method described below.
\layout Subsubsection

Interfaces
\layout Paragraph

Video camera on Motorola platform
\layout Standard

Functions provided on the Motorola board for accessing the camera:
\layout LyX-Code

int QC_init (void);
\layout Standard

This function initialises the camera and must be called before 
\family typewriter 
QC_grabframe
\family default 
; it returns 
\family typewriter 
QC_SUCCESS
\family default 
 if successful, 
\family typewriter 
QC_TIMEOUT
\family default 
 if the camera fails to respond, or 
\family typewriter 
QC_BAD_RESPONSE
\family default 
 if the camera does not respond correctly.
\layout LyX-Code

int QC_grabdata (char * buffer, int amount);
\layout Standard

This function grabs 
\family typewriter 
amount
\family default 
 bytes from the camera into the buffer pointed to by 
\family typewriter 
buffer
\family default 
.
 A complete frame is 19200 bytes (
\begin_inset Formula \( 160\times 120 \)
\end_inset 

) in length.
 Each pixel is encoded as an 
\family typewriter 
unsigned char
\family default 
 of value 0 to 15 inclusive representing the colour of the pixel where 0
 represents black, and 1--15 represent white to near-black
\begin_float footnote 
\layout Standard

Note that we later change this mapping of number to colours so that the
 numbers 0 to 15 represent the colours black through to grey, to white.
\end_float 
.
\layout Paragraph

Graphical User Interface on Linux platform
\layout Standard

The following function is provided on the Linux platform for the video code:
\layout LyX-Code

void display_image (unsigned char * image);
\layout Standard

This function displays the image pointed to by 
\family typewriter 
image
\family default 
 which should be an array of size 19200 representing the image to be displayed.
 The image should be in the same format as received from the camera on the
 Motorola board but after the colours have been re-mapped so that 0 represents
 black, 15 represents white, and values in between 0 and 15 represent various
 grays increasing in brightness.
\layout Subsubsection

Image compression algorithm
\layout Standard

As previously described, the image compression obtains the difference between
 the current frame and the previous frame and then uses run length encoding
 to compress the resulting image.
\layout Paragraph

Frame difference
\layout Standard

To obtain the difference between a frame and the previous frame, the bitwise
 exclusive-or function is used.
 This has the advantage that the Motorola MC68040 CPU can rapidly perform
 this operation.
 If the frame being compressed is the first frame then it is exclusive-or'd
 with a frame consisting of 0's, which will result in it being unchanged.
 There is the additional advantage that the MC68040 can perform this operation
 on 4 bytes at a time.
\layout Standard

To obtain the original frame given the difference between it and the previous
 frame, the exclusive-or function is used to combine the difference with
 the previous image.
\layout Paragraph

Run-length encoding
\layout Standard

The run-length encoding algorithm treats the encoded data as a stream of
 5 bit segments.
 The first bit of the next segment indicates whether it encodes an individual
 pixel, or whether it encodes several pixels.
 If the value of the first bit is 0 then the subsequent 4 bits represent
 the value of an individual pixel
\begin_float footnote 
\layout Standard

4 bits is sufficient to store a value between 0 and 15 inclusive, and thus
 sufficient to store the colour of a pixel.
\end_float 
.
 If the value of the first bit is 1 then the subsequent 4 bits represent
 the value of a pixel, and the subsequent 5 bit block represents the number
 of adjacent pixels with that value.
 The decoding algorithm will terminate when an expected number of bytes
 have been decoded (this has the advantage that if the compressed data is
 corrupted the decompression will never overrun the output buffer).
\layout Subsubsection

Transmission format
\layout Standard

The compressed image is transmitted as a single byte with value 0 or 1,
 followed by the compressed data.
 If the value of the first byte is 1 then the receiving software will assume
 that this is a new frame in a sequence and will treat it as such (rather
 than combining it with the previous frame).
\layout Subsection

Audio
\layout Standard

The audio system is responsible for sampling, compressing, decompressing
 and reproducing sound data from both PC and Motorola board.
 Due to the fact that only speech data actually needs to be sent, the data
 rate can be reduced immediately by not bothering to sample frequencies
 above 4kHz since the human voice only ranges from approximately 200Hz to
 3.5kHz.
 In order to sample this accurately we require a sampling rate of double
 the highest frequency we wish to capture, 
\emph on 
i.e.

\emph default 
 8kHz.
 To keep the data to a minimum, 8-bit data is used and there is obviously
 very little point in using stereo.
 This basic requirement of 8kHz, 8-bit, mono sound gives us a data-rate
 of 64,000 bits per second.
 Clearly, in order to squeeze this into the 38.4kbps serial line, we must
 use some form of compression.
\layout Subsubsection

Evolution
\layout Standard

The original concept was to use ADPCM compression to give high-quality,
 low data-rate, speech.
 This system would have got the audio down to 16kbps which would have allowed
 a bit of bandwidth for video as well.
 It was found that, with the code we were using, the compression took approximat
ely 20% of the CPU time on an Intel Pentium MMX running at 200MHz, as did
 the decompression; therefore it was decided to drop the ADPCM compression
 in favour of a less computationally intensive method, achieving less compressio
n with slightly lower quality, although this is offset by the fact that
 it can actually be performed extremely quickly --- using just two array
 lookups for compression, and one for decompression.
 It is still believed that ADPCM could be made to work on the Motorola board,
 and that that would be a better solution than the one currently implemented.
 This is primarily due to the fact that it gives somewhat better reproduction
 that our own method which just approximates the sound.
 ADPCM uses signal processing techniques to achieve its compression; these
 have been honed through years of research.
 If there had been enough time to try various techniques, then perhaps the
 code could have been optimised enough to be used on the MC68040.
 Given that it was discovered that the algorithm was more complex than it
 initially appeared to be, and given the time constraints, a decision had
 to be made --- that decision was to go with a solution that was known to
 be efficient enough to run on the system as is.
\layout Standard

Originally we had intended to implement a full-duplex solution since it
 posed few real extra problems, and actually simplified the sound system's
 integration.
 However, it was found that the Linux drivers for the PC's soundcard do
 not support its full-duplex functionality.
 Consequently, we were limited to half duplex audio.
\layout Subsubsection

Interfaces
\layout Paragraph

Linux interfaces
\layout Standard

On the Linux side, we need an interface to the Linux Open Sound System (OSS).
 This is an API which allows simple access to the sound hardware via the
 operating system and comes built-in as part of the Linux kernel.
 It provides a layer of abstraction between the hardware and the software
 which uses it.
 It is slightly beyond the remit of this document to describe it fully here
 as there is adequate documentation elsewhere.
 The world wide web URL which used to find information about the system
 is http://www.4front-tech.com/pguide/audio.html.
\layout Standard

Essentially, the soundcard is simply opened, via the 
\family typewriter 
open
\family default 
 function which takes as its arguments
\layout Itemize

the device to open
\layout Itemize

the mode to open it in 
\layout Itemize

an integer 
\layout Standard

For the purposes of opening the soundcard, the integer is set to zero.
 
\family typewriter 
open
\family default 
 then returns an integer which is the file descriptor for the soundcard
 stream.
\layout Standard

Sound is sampled using 
\family typewriter 
read
\family default 
 which takes 
\layout Itemize

the integer file descriptor returned by 
\family typewriter 
open
\layout Itemize

a pointer to a buffer in which to put the sample 
\layout Itemize

an integer which defines the length of the sample.
 
\layout Standard

Similarly, samples are sent to the soundcard using 
\family typewriter 
write
\family default 
.
\layout Paragraph

Motorola
\layout Standard

The Motorola side of the audio system is a little more complex in its programmin
g but much simpler to use.
 It accesses the ADC and DAC on the secondary board via the board's memory-mappe
d MC68230.
\layout Standard

The audio system is initialised by setting the MC68230's port A's bits 7--5
 direction to output, then sending 
\family typewriter 
E0
\family default 
 hex to port A.
\layout Standard

To play a sample, we set the correct direction on port A, set port B to
 all output, output the sample on port B, and latch the DAC by outputting
 
\family typewriter 
A0
\family default 
 then 
\family typewriter 
E0
\family default 
 hex to port A (toggling bit 6).
\layout Standard

To grab a sample, we set the correct direction on port A, set port B to
 all input, output 
\family typewriter 
60
\family default 
 hex to port A, read the sample from the alternate port B register, and
 reset port A to 
\family typewriter 
E0
\family default 
 hex (toggling bit 7).
\layout Subsubsection

Audio codec
\layout Paragraph

Compression algorithm
\layout Standard

The audio compression is now as follows.
 When a sample is received, the delta between it and the previous sample
 is calculated.
 This delta is then encoded as a 4-bit nibble with the values from 0--15
 representing 
\begin_inset Formula \( -128 \)
\end_inset 

, 
\begin_inset Formula \( -64 \)
\end_inset 

, 
\begin_inset Formula \( -32 \)
\end_inset 

, 
\begin_inset Formula \( -16 \)
\end_inset 

, 
\begin_inset Formula \( -8 \)
\end_inset 

, 
\begin_inset Formula \( -4 \)
\end_inset 

, 
\begin_inset Formula \( -2 \)
\end_inset 

, 
\begin_inset Formula \( -1 \)
\end_inset 

, 1, 2, 4, 8, 16, 32, 64, 127 respectively.
 The value taken by the compression is the 4-bit representation that is
 closest to the actual delta.
 For example, if the difference between samples is 
\begin_inset Formula \( -16 \)
\end_inset 

, the nearest coding for this is 
\begin_inset Formula \( -16 \)
\end_inset 

, which is represented as 3 or 
\family typewriter 
0011
\family default 
 binary.
 For the codec keeps in step, the compressor then adds the coded value of
 the delta to the previous sample value and proceeds with this modified
 estimation of the current sample.
 A table has been created to give fast computation of the closest-fit encoding,
 To find the necessary encoding, all that needs to be done is to calculate
 the delta and then reference the array in the appropriate position.
\layout Standard

Similarly there is another table which gives the inverse mapping.
 That is, when given an encoding, it will return the required estimate of
 the delta.
\layout Standard

The 
\family typewriter 
initCompr
\family default 
 function initialises the algorithm so that the 
\begin_inset Quotes eld
\end_inset 

previous
\begin_inset Quotes erd
\end_inset 

 sample's value is in the middle of the range.
 Similarly, the 
\family typewriter 
initDecompr
\family default 
 function
\series bold 
 
\series default 
performs the same function for the decompression side.
\layout Standard

The functions 
\family typewriter 
unsigned char compressI (unsigned char)
\family default 
 and 
\family typewriter 
unsigned char decompressI (unsigned char)
\family default 
 perform the respective mappings: 
\family typewriter 
compressI
\family default 
 takes an 8-bit unsigned sample and returns the encoding for it in the lower
 4 bits of an 
\family typewriter 
unsigned char
\family default 
, and 
\family typewriter 
decompressI
\family default 
 taking the 4-bit encoding and returns the estimated sample.
\layout Standard

There are two further functions, 
\family typewriter 
unsigned char compress (unsigned char, unsigned char)
\family default 
 and 
\family typewriter 
void decompress (unsigned char, unsigned char *)
\family default 
; the first takes two samples and returns an 8-bit word containing the two
 encodings, the encoding of the first sample in the high part, and the second
 in the low part; the second takes an 8-bit word of this form and returns
 the two estimates of the samples in an array, a pointer to which is passed
 as the second argument.
\layout Paragraph


\begin_inset LatexCommand \label{Linux audio}

\end_inset 

Linux codec
\layout Standard

The Linux side is forked from the main GUI and run as a separate process;
 the GUI and the audio codec communicate using the 
\family typewriter 
SIGUSR1
\family default 
 and 
\family typewriter 
SIGUSR2
\family default 
 signals.
 
\family typewriter 
SIGUSR1
\family default 
 indicates that the codec should move to 
\family typewriter 
l_state4
\family default 
, which is the transmits audio to the Motorola board, or, if it is already
 in this state, stop.
 Similarly 
\family typewriter 
SIGUSR2
\family default 
 is used to signal 
\family typewriter 
l_state10
\family default 
 to start receiving audio from the Motorola or to stop receiving if it already
 is.
\layout Standard

If the codec receives a signal, it causes the current state to cease, and
 this process sets the Motorola board to listen for a state number to move
 into.
 This is achieved in state 4 by sending a byte of 
\family typewriter 
FF
\family default 
 hex to the board and then quitting, and in state 10 by simulating a ping
 which causes the serial code on the Motorola to wait until a byte is received
 and then return the value of that byte to the calling function which will
 then, in turn return that value to 
\family typewriter 
main
\family default 
 which will cause the system to assume that state.
\layout Standard


\family typewriter 
l_state4
\family default 
 uses the 
\family typewriter 
init_audio
\family default 
 and 
\family typewriter 
sendSample
\family default 
 functions.
\layout Standard


\family typewriter 
init_audio (int)
\family default 
 takes an open mode for the soundcard and then opens the device in that
 mode and sets it up for 8kHz, 8-bit mono operation.
 Modes include 
\family typewriter 
O_RDONLY
\family default 
 for reading, and 
\family typewriter 
O_WRONLY
\family default 
 for writing.
\layout Standard


\family typewriter 
sendSample (void)
\family default 
 calls 
\family typewriter 
getsample (char *)
\family default 
 which grabs 
\family typewriter 
SAMPLE_BUF_SIZE
\family default 
 samples into the buffer pointed to by the argument.
 It then runs 
\family typewriter 
compress_sample (char *, char *)
\family default 
 which takes this data and compresses it.
 
\family typewriter 
sendSample
\family default 
 then goes through the compressed data and sends it a byte at a time using
 
\family typewriter 
serialtransmit
\family default 
 to the Motorola board.
\layout Standard


\family typewriter 
l_state10
\family default 
\series bold 
 
\series default 
again initialises the audio and then receives 
\family typewriter 
PLAY_BUF_SIZE
\family default 
 bytes of compressed audio data from the serial port, but then runs 
\family typewriter 
receiveSample
\family default 
 which runs 
\family typewriter 
decompress_sample
\family default 
 on that data (giving a buffer's worth of uncompressed audio data) and then
 outputs this to the soundcard using 
\family typewriter 
setsample
\family default 
.
\layout Paragraph

Motorola codec
\layout Standard

This is the corresponding codec for the motorola board; it forms part of
 the state machine that runs on the IDP board and comprises two states,
 implemented as functions.
\layout Standard


\family typewriter 
int state4 (void)
\family default 
 grabs a byte from the serial port then loops: it decompresses a byte into
 two samples and plays the first sample; grabs a byte from the serial port,
 plays the second decompressed sample; decompresses the next byte, plays
 the first sample and so on.
 Thus it utilises the time between playing samples quite effectively, giving
 an even spread of processor time rather than having to grab, decompress
 and play then wait whilst doing nothing for a while, play another sample
 then loop.
 If the state ever receives a hex 
\family typewriter 
FF
\family default 
, then it will expect to receive one of two things: either another 
\family typewriter 
FF
\family default 
 indicating that it should play that as a sample, or a number indicating
 a state change.
 If it is the latter, the function stops looping and returns the second
 byte as its return value.
\layout Standard


\family typewriter 
int state10 (void)
\family default 
 grabs a sample, then loops: it grabs a sample, compresses the last two
 samples (if any), grabs a sample, sends the compressed data (again, if
 any), grabs a sample, and so on.
 If the 
\family typewriter 
serialtransmit
\family default 
 function that is called to send the sample to the Motorola ever returns
 a non-zero value, then the function ends, returning this value thereby
 causing a state change.
\layout Subsection

Support routines
\layout Standard

Two support routines are defined on the Motorola.
\layout Standard


\family typewriter 
void puts (char * string)
\family default 
 prints the given string to the monitor.
\layout Standard


\family typewriter 
void putn (unsigned long number, int base, int digits)
\family default 
 prints 
\family typewriter 
number
\family default 
 in base 
\family typewriter 
base
\family default 
 using 
\family typewriter 
digits
\family default 
 digits.
\layout Section

The Motorola state machine
\layout Standard

The state diagram is given in figure 
\begin_inset LatexCommand \ref{Motorola state diagram}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Motorola state diagram}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 446 360
file statediagram.eps
width 3 75
angle 270
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{Motorola state diagram}

\end_inset 

Motorola state diagram
\end_float 
\layout Standard

The Motorola program may be in any one of these states at any given time,
 but the transitions are tightly defined.
 Note that due to late changes, states 6 and 9 are non-existent.
\layout Subsection

Initialisation (state 1)
\layout Standard

This state initialises the various modules using their initialisation functions.
 In theory it should also retrieve configuration information and the user
 database from the PC.
\layout Paragraph

Transitions
\layout Standard

State 2 is entered on completion of the above.
\layout Paragraph

Communications to and from the PC
\layout Standard

Configuration information and the database are requested from the client's
 control module using 
\family typewriter 
CONTROL
\family default 
 packets.
\layout Paragraph

Modules
\layout Standard

This state makes use of all the support modules --- it needs to initialise
 everything.
\layout Subsection

Default mode (state 2)
\layout Standard

This state polls the iButton reader and the buzzer, captures an image and
 sends it to the PC.
 If the doorbell is pressed, it informs the PC.
\layout Paragraph

Transitions
\layout Standard

This state can move to state 1, given the appropriate signal from the PC,
 state 3, if the doorbell is pressed, state 5, if an iButton is detected,
 or state 2 by looping.
\layout Paragraph

Communications to the PC
\layout Standard

Video is communicated using 
\family typewriter 
VIDEO
\family default 
 packets.
\layout Paragraph

Communications from the PC
\layout Standard

A state-change may be requested using a 
\family typewriter 
PING
\family default 
 packet and the special protocol.
\layout Paragraph

Modules
\layout Standard

This state uses the serial, low-level and video modules.
\layout Subsection

Watch (state 3)
\layout Standard

This state simply transmits video until it times out or the client acknowledges
 the doorbell, using a state change.
\layout Paragraph

Transitions
\layout Standard

This state can move to state 2, if the timeout expires (
\emph on 
i.e.

\emph default 
 the client fails to respond), state 4, if the client responds to the doorbell
 signal, or state 3, by looping.
\layout Paragraph

Communications to the PC
\layout Standard


\family typewriter 
CONTROL
\family default 
 messages informs the PC that the buzzer has been pressed.
\layout Paragraph

Modules
\layout Standard

This state uses the serial and video modules.
\layout Subsection

Talk (state 4)
\layout Standard

This state allows the PC user to talk to the visitor.
 It samples audio on the PC, compresses it, and transmits it to the Motorola
 which decompresses it and plays it back.
\layout Standard

Note that this state is not actually functional as of May 14, 1998.
 There is a problem with the PC-to-Motorola audio system which has proved
 difficult to track down.
 At present, it is believed that the bug lies in the PC-side compression,
 although as to why this should be the case is, as yet, uncertain.
 The following is a discussion of how the state should actually work, in
 reality, it is a dummy state which simply waits to receive a state transition.
 It should be further noted that this state transition is compliant with
 the actual design so that it is not too far divorced from the finished
 product.
 Having said that, the Motorola side is absolutely normal, and should work
 if you send it correct data.
\layout Paragraph

Transitions
\layout Standard

State change requests will cause this state to move to state 2, if the timeout
 triggers, state 7, if the PC refuses entry, state 8, if the PC allows entry,
 or state 10, if the PC wants to listen.
 Otherwise state 4 will loop.
\layout Paragraph

Communications to the PC
\layout Standard

This state uses its own audio protocol to transmit state change requests.
\layout Paragraph

Communications from the PC
\layout Standard

Again, this state uses its own protocol to transmit audio.
\layout Paragraph

Modules
\layout Standard

This state uses the serial and audio modules.
\layout Subsection

Authenticate (state 5)
\layout Standard

This state reads the iButton information and a PIN, and verifies the user's
 authenticity.
\layout Paragraph

Transitions
\layout Standard

This state will move to state 2 on error, state 8 to open the door, or state
 7 to deny entry.
\layout Paragraph

Modules
\layout Standard

This state uses the low-level and control modules.
\layout Subsection

Refuse entry (state 7)
\layout Standard

This state flashes the red LED to indicate authentication failure.
\layout Paragraph

Transitions
\layout Standard

State 2 is entered on completion.
\layout Paragraph

Modules
\layout Standard

This state uses the low-level module.
\layout Subsection

Open door (state 8)
\layout Standard

This state activates the green LED, hence opening the door, and waits for
 a timeout or the door to shut before switching the LED back off.
\layout Paragraph

Transitions
\layout Standard

State 2 is entered on completion.
\layout Paragraph

Modules
\layout Standard

This state uses the low-level module.
\layout Subsection

Listen (state 10)
\layout Standard

This state allows the PC use to listen to the visitor.
 It samples audio on the Motorola, compresses it, and transmits it to the
 PC which decompresses it and plays it back.
\layout Paragraph

Transitions
\layout Standard

State 4 is entered if the PC wants to talk; states 7 or 8 are entered if
 access is respectively denied or granted; state 2 is entered on timeout.
 Otherwise state 10 loops.
\layout Paragraph

Communications to the PC
\layout Standard


\family typewriter 
AUDIO
\family default 
 packets carry the audio.
\layout Paragraph

Communications from the PC
\layout Standard

The standard state-change mechanism is used.
\layout Paragraph

Modules
\layout Standard

This state uses the audio and serial modules.
\layout Section

The graphical user interface
\layout Standard

The user interface runs on the Linux PC under X.
 Its primary functions are the display of images from the camera at the
 door, and to let the user allow or refuse entry to callers based on the
 camera image.
 It also allows configuring of the user database, and changing of various
 settings such as audio volumes.
 The interface was built using GTK, an X toolkit which eases development,
 and provides good-looking GUI components.
\layout Subsection

Evolution
\layout Standard

The interface started off as a simple window which contained a picture so
 the image transfer from the camera could be tested.
 Buttons were added later to perform various functions, including user communica
tion to various other modules.
 
\layout Subsection

User interface design
\layout Standard

The user interface can be in one of two visual states.
 The default is shown in figure 
\begin_inset LatexCommand \ref{Grab 1}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Grab 1}

\end_inset 

.
 This corresponds to state 2 in the Motorola state model, described elsewhere
 in this document.
 
\layout Subsubsection

Idle mode
\layout Standard

The window in this state comprises of an image area, four buttons and a
 status bar.
 The 
\shape italic 
video
\shape default 
 button is only really used in the second of the visual states.
 It is included here to provide a facility for recapturing video frames
 if they become corrupted for some reason.
 
\shape italic 
Audio
\series bold 
\shape default 
 
\series default 
\shape italic 
control
\shape default 
 launches an audio mixer program for adjusting speaker and microphone volumes.
 This is completely independent of the user interface, but is included for
 convenience.
 
\shape italic 
Configure
\shape default 
 launches the configuration program.
 Its main function is to edit the user database (see section 
\begin_inset LatexCommand \ref{Database system}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Database system}

\end_inset 

), but in future will be used to change other configuration options.
 As before, it is completely independent of the main user interface program.
 
\shape italic 
Close
\shape default 
 will quit the program completely after killing the audio process (see section
 
\begin_inset LatexCommand \ref{Linux audio}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Linux audio}

\end_inset 

).
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 170 125
file ../../guigrab1.ps
width 1 6
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{Grab 1}

\end_inset 

The user interface in its default state
\end_float 
\layout Subsubsection

Door entry mode
\layout Standard

This mode, illustrated in figure 
\begin_inset LatexCommand \ref{Grab 2}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Grab 2}

\end_inset 

, becomes active when a 
\family typewriter 
DOORBELL
\family default 
 control message is received from the board.
 Control messages are documented in the serial transport section 
\begin_inset LatexCommand \ref{Packets}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Packets}

\end_inset 

.
 A number of buttons are added to those already present in the window.
 In this state, the interface can be in one of three modes which govern
 the operation of the audio/video components.
 These are 
\shape italic 
Talk
\shape default 
, 
\shape italic 
Listen
\shape default 
 and 
\shape italic 
Video
\shape default 
, represented as standard pushbuttons.
 The status bar at the bottom of the window indicates which of the three
 modes is currently active.
 Clicking these buttons send various state-change messages.
 These modes are necessary because full-duplex audio is not possible because
 of problems with the Linux end, and we do not try to implement simultaneous
 audio and video feeds down a slow serial line.
 Hence we need a switching mechanism between the three modes.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 170 134
file ../../guigrab2.ps
width 1 6
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{Grab 2}

\end_inset 

The user interface when the doorbell is rung
\end_float 
\layout Standard

The other two buttons added in this mode are 
\shape italic 
Unlock
\shape default 
 and 
\shape italic 
Refuse
\shape default 
.
 Clicking these send the relevant message to the board, and sends the user
 interface back to Idle mode, removing the buttons added, and moving back
 to Video mode if talking or listening.
\layout Standard

Another feature of the door entry mode is user notification of the doorbell
 press, which is both audible and visual.
 A small window pops up, displaying an XPM picture, loaded directly off
 disk, and a message.
 We use a GTK function to load and display the picture, which saves programming
 time.
 Loading off disk also means that the picture is user configurable.
 At the same time, a WAV audio sample is played.
 We use a Unix shell script to send a WAV file to the audio device.
 Again, using a file makes the sample user configurable.
\layout Subsection

Startup
\layout Standard

The Linux binary contains code for user interface, video and serial transport.
 The serial is handled by operating system events, so just needs to be initialis
ed.
 The audio is run in a separated process, and as such, needs to be 
\family typewriter 
fork
\family default 
ed off as a child process from the user interface.
 This is done in 
\family typewriter 
main
\family default 
.
 The audio process is killed when the GUI exits.
 ie.
 when 
\shape italic 
close
\shape default 
 is clicked.
\layout Subsection

External interfaces
\layout Standard

The user interface module communicates with the following system components:
\layout Subsubsection

PC video module
\layout Standard

After the video module receives a frame from the board (via the serial transport
 module), it calls 
\family typewriter 
display_image (char * image)
\family default 
 to give its image to the user interface.
 This image is in a simple format where each byte value represents the 16-point
 greyscale value of a pixel.
 As the image dimensions are fixed, this can be interpreted as an image.
 
\layout Standard

The easiest way to use images in the GTK toolkit is to present them in the
 XPM format.
 We also decided to double the size of the source image, as it is too small
 for screen display.
 Hence, the internal function 
\family typewriter 
double_xpm (char * image)
\family default 
 is used to double the image size and convert to XPM format in one pass.
 It is then simply passed to the GTK tookit, which displays it as an X widget.
 As 
\family typewriter 
display_image
\family default 
 is called whenever a video frame is received from the Motorola board the
 image in the window is continually updated.
\layout Standard

An important point about the way frame update works is the following.
 The user interface normally sits in a loop called 
\family typewriter 
gtk_main
\family default 
 until an event occurs.
 It does not need to know about the frame update because the serial transport
 module calls an interrupt when it receives an image.
 Hence, all the above happens as a result of an interrupt handler call.
 After the interrupt exits, the program goes back to its event loop.
\layout Subsubsection

PC audio module
\layout Standard

The selection of the three different operation modes described previously
 mean that the GUI needs to tell the audio process when to start and stop
 the audio, and in which direction to channel it.
 Since audio is a separate process, this is done using Unix signals.
 
\layout Standard

There are two signals available for custom use; 
\family typewriter 
SIGUSR1
\family default 
 and 
\family typewriter 
SIGUSR2
\family default 
.
 We set up signal handlers in the audio process, so the GUI can send signals
 in the following fashion:
\layout Itemize


\family typewriter 
SIGUSR1
\family default 
: start audio from Linux to Motorola (
\shape italic 
Talk
\shape default 
 button);
\layout Itemize


\family typewriter 
SIGUSR2
\family default 
: start audio from Motorola to Linux (
\shape italic 
Listen
\shape default 
 button);
\layout Itemize

either signal sent again while its corresponding direction is active will
 stop the audio in that direction.
\layout Subsubsection

Motorola state machine
\layout Standard

As well as telling the PC audio module to start or stop, we also need to
 notify the motorola board to change into the correct state.
 This is done using the serial transport function 
\family typewriter 
serialtransmit
\family default 
 and 
\family typewriter 
changestate
\family default 
, which are described elsewhere in this document.
 
\layout Standard

This approach is also used to facilitate the starting and stopping of the
 video feed, which again is governed by which state the motorola is in.
 In the same way, clicking the 
\shape italic 
unlock
\shape default 
 and 
\shape italic 
refuse
\shape default 
 buttons will send 
\family typewriter 
changestate
\family default 
 packets to the Motorola, moving it to either the unlock state or the refuse
 state.
\layout Section


\begin_inset LatexCommand \label{Database system}

\end_inset 

The Database system
\layout Subsection

Linux
\layout Subsubsection

Structure
\layout Standard

The original design was to store the database on disk on the PC.
 This was to be downloaded onto the Motorola on power-up.
 All the code exists to do this, but is not fully integrated yet.
 An intermediate solution was to hard-code the database into the Motorola
 binary.
 This is the state of the system at present, although it would not take
 much effort to fully integrate it.
 As such, the Linux side of the database system is not in use at present.
 It will be described for completeness.
\layout Standard

The structure of a database record on the PC differs from that on the Motorola.
 The latter stores only a list of iButton serial numbers and corresponding
 PINs, whereas the former stores much more.
 It is described below.
\layout LyX-Code

struct db_struct { 
\layout LyX-Code


\protected_separator 
 char uid[UID_SIZE+1]; 
\layout LyX-Code


\protected_separator 
 char pin[PIN_SIZE+1]; 
\layout LyX-Code


\protected_separator 
 char fname[NAME_SIZE+1]; 
\layout LyX-Code


\protected_separator 
 char sname[NAME_SIZE+1]; 
\layout LyX-Code


\protected_separator 
 char dept[NAME_SIZE+1]; 
\layout LyX-Code


\protected_separator 
 char photo[NAME_SIZE]; 
\layout LyX-Code


\protected_separator 
 char lock; 
\layout LyX-Code


\protected_separator 
 struct db_struct *next; 
\layout LyX-Code

};
\layout Standard

As the above shows, the database is stored in memory as a linked list of
 these structures.
 The function reads an ASCII file with each line containing a space-separated
 record.
 It then dynamically allocates memory for each record, and creates the linked
 list.
 An example of where this is used is the configuration program, where one
 can edit the user database.
\layout Subsubsection

Download
\layout Standard

In the finished system, the Motorola startup routine (state 1) requests
 a download from PC by transmitting a certain value.
 The PC then loads the database, and transmits the UID/PIN pair for each
 user using a packet format.
 The Motorola receives these packets and saves the data into memory.
\layout Subsubsection

User Interface
\layout Standard

The database user interface allows an administrator to manage the users
 of the iDoor system.
 This includes operations such as adding or deleting a user, changing a
 PIN, or viewing a log of entries made by a particular person.
 At this stage, the level of functionality of this part of the system is
 quite low.
 The interface itself is, however, complete.
 This gives an idea of the 
\begin_inset Quotes eld
\end_inset 

look and feel
\begin_inset Quotes erd
\end_inset 

 of the finished product.
 An example database window is shown in figure 
\begin_inset LatexCommand \ref{Database window}

\end_inset 

, page 
\begin_inset LatexCommand \pageref{Database window}

\end_inset 

.
\layout Standard

\begin_float fig 
\layout Standard
\align center 

\begin_inset Figure size 283 192
file ../../db_grab.ps
width 1 10
flags 9

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{Database window}

\end_inset 

The database window
\end_float 
\layout Subsection

Motorola
\layout Subsubsection

Structure
\layout Standard

The structure of a database record on the Motorola is simply UID / PIN pairs,
 as shown below.
 Nothing else is needed for automatic validation.
 The rest of the data stored on the PC is really just for convenience.
 Another difference is that the memory to hold the database is not dynamically
 allocated --- as the board has no operating system, no 
\family typewriter 
malloc
\family default 
 function is available.
 This means that the database store is not a linked list, but an array.
 The size must be specified at compile time, and therefore we use a 
\family typewriter 
MAX_USERS
\family default 
 define for this purpose.
 The 
\family typewriter 
\shape italic 
actual
\family default 
\shape default 
 size of the database within this array can be determined because an 
\begin_inset Quotes eld
\end_inset 

end-of-file
\begin_inset Quotes erd
\end_inset 

 character 'X' is inserted in the first element of the last uid string.
 This is fine for our purposes, as a real iButton uid is a hex number, and
 hence only uses characters up to F.
\layout LyX-Code

typedef struct { 
\layout LyX-Code


\protected_separator 
 char uid[UID_SIZE+1]; 
\layout LyX-Code


\protected_separator 
 int pin; 
\layout LyX-Code

} local_db_item;
\layout Subsubsection

Validation
\layout Standard

State 5 is the user validation state.
 It is entered into when an iButton has been detected in the reader.
 The serial number (or uid) is read using low-level functions, and copied
 into a global variable.
 We then wait for a keypress four times, each time 
\begin_inset Quotes eld
\end_inset 

appending
\begin_inset Quotes erd
\end_inset 

 that digit onto the global pin integer variable.
 An int is used here for ease of comparison with the database.
 It cannot be used for the uid because the base-10 version of the hex uid
 could not be stored in an int.
\layout Standard

After reading the fourth digit, 
\family typewriter 
validate_user()
\family default 
 is called.
 First, this function searches the database for the uid.
 This is done linearly, although in future designs it could be a more efficient
 search (eg.
 binary).
 Next, if the uid is found, it compares the PIN paired with that uid with
 the entered PIN.
 Depending on the outcome of this test, the Motorola state will get moved
 to unlock or refuse respectively.
\layout Section

Tools used
\layout Standard

The tools used during development were
\layout Itemize

Text editor: XEmacs 19.15;
\layout Itemize

Compiler: GNU C Compiler 2.7.2.1, for Linux 
\emph on 
x
\emph default 
86 and the IDP board;
\layout Itemize

Word processor: LyX 0.12.0;
\layout Itemize

X toolkit: GTK+ 1.0.0.
\the_end
